[{"authors":null,"categories":null,"content":"I am a postdoc at the MPI CPFS (Intermetallic Chemistry Group). I have a PhD in theoretical and computational chemistry. Currently, I am working on extending Interacting Quantum Atoms to solid state systems. My interests include topological quantum chemistry, chemical bonding, and scientific computing.\nBesides theoretical chemistry, I am enthusiastic about the rise of quantum computing and machine learning. Biking and snowboarding are two of my favorite hobbies.\nSometimes I write about science using Julia in this site. Stay tuned!\n  Download my resumÃ©.\n","date":-62135596800,"expirydate":-62135596800,"kind":"term","lang":"en","lastmod":-62135596800,"objectID":"2525497d367e79493fd32b198b28f040","permalink":"","publishdate":"0001-01-01T00:00:00Z","relpermalink":"","section":"authors","summary":"I am a postdoc at the MPI CPFS (Intermetallic Chemistry Group). I have a PhD in theoretical and computational chemistry. Currently, I am working on extending Interacting Quantum Atoms to solid state systems.","tags":null,"title":"Daniel MenÃ©ndez Crespo","type":"authors"},{"authors":["Daniel MenÃ©ndez Crespo","Frank Richard Wagner","Evelio Francisco","Ãngel MartÃ­n PendÃ¡s","Yuri Grin","Miroslav Kohout"],"categories":null,"content":"","date":1633117410,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1633117410,"objectID":"f511e9b1a9152a549313270a9d288a40","permalink":"https://zyth0s.github.io/publication/iqa-solids/","publishdate":"2021-10-01T19:43:30.974Z","relpermalink":"/publication/iqa-solids/","section":"publication","summary":"An implementation of the Interacting Quantum Atoms method for crystals is presented.","tags":null,"title":"Interacting Quantum Atoms Method for Crystalline Solids","type":"publication"},{"authors":[],"categories":[],"content":"Science is an indisputable source of progress for our society. A topical example is the use of recent advances in biochemistry to foster new vaccines for Sars-CoV-19.\nThe compendium of acquired scientific knowledge is so vast that nobody is expected to be illustrated in every branch of science, not even a field or subfield. For that reason it is difficult to even be aware of the main questions, concepts or definitions addressed currently by almost any discipline. In this regard, it would be helpful if we had at our disposal a collection of brief descriptions for them.\nHere we seek to condense in the least amount of words, images, or recording length a given concept in science. Much like memes in Dawkins' description of the term (and contrary to popular usage) scientific memes are meant to be units of scientific information, such as a scientific concept or question, that are transmitted verbally or visually from one mind to another.\nNow you might ask how should those memes be. Something like a dictionary entry? Quite not. We would like a more rich medium, with some illustration to it. A very good example is the following explanation of Fourier transform by Stuart Riffle.\nThe same format has been used to explain other mathematical concepts (examples taken from Better explained)\nA not less impressive format is used by physics professor Yuri Kovalenok. The following is only an example of a large collection of notebook notes handwritten by Yuri\nMore like that by twitter user @ThuyNganVu\nThose notes are based on videos recorded by Youtube user 3blue1brown.\nI am pretty sure there are more examples like those around but those are the ones I encountered. Often when I learn a new concept I try to leave a note for myself that helps me when I forget what is the meaning.\n Umklapp process: part of the momentum that the neutron gives to the solid goes to the centre of mass of the solid. The other part transforms into phonon modes. Anderson \u0026amp; Kondo? Is the hybridisation of strongly correlated electron states with free electron bands. The problem is how to hybridise states of completely different nature. Pierls instability is like the resonance in poly-acetylene between alternating bonds. The system spontaneously dimerises in two resonant ground state configurations. Bloch states are closely related to chemists resonant structure concept â€œModern Cond matter physics bookâ€ Spin-orbit coupling: Physically it can be understood as the Zeeman coupling between the magnetic moment carried by electron spin and the effective magnetic field seen by the electron in the reference frame in which it is at rest, while the other charges move around it â€œModern Condensed matter Physics bookâ€ Oxidation state: is the formal charge minus electrons shared with less electronegative atoms. Josephson junction â€“ a non-superconducting region through which the Cooper pairs responsible for superconductivity can tunnel. This semiconducting â€œweak linkâ€ provides a persistent phase difference between the superconductors in the circuit, similar to the way that a classical battery provides a persistent voltage drop in an electronic circuit. Thanks to this phase difference, a superconducting current (that is, a current with zero dissipation) flows when the junction is embedded in the superconducting circuit Featured in Physics World Hereâ€™s an extremely brief version of the black hole information paradox: Stuff falls into a black hole. Over time â€” a long, long time â€” the black hole â€œevaporates.â€ What happened to the stuff? According to the rules of gravity, itâ€™s gone, its information lost forever. But according to the rules of quantum mechanics, information can never be lost. Therefore, paradox.Â Featured in Quanta magazine TheÂ biggest puzzle in cosmology right nowÂ has to do with the Hubble constant, a measure of the speed at which the universe is expanding. Data from the early universe predicts one value. Data from the modern universe predicts another. Featured in Quanta magazine Hawking radiation by Gaston Giribet.  ","date":1609774635,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1609774635,"objectID":"126b315f171bdb7932cf7f4a2949e361","permalink":"https://zyth0s.github.io/post/scientific-memes/","publishdate":"2021-01-04T16:37:15+01:00","relpermalink":"/post/scientific-memes/","section":"post","summary":"Science is an indisputable source of progress for our society. A topical example is the use of recent advances in biochemistry to foster new vaccines for Sars-CoV-19.\nThe compendium of acquired scientific knowledge is so vast that nobody is expected to be illustrated in every branch of science, not even a field or subfield.","tags":[],"title":"Scientific Memes","type":"post"},{"authors":null,"categories":["Quantum Computing"],"content":"Jupyter notebook here.\nVariational Quantum Eigensolver (VQE) algorithm is a quantum realization of Ritz\u0026rsquo;s variational method.\nA more lengthy explanation is given by MichaÅ‚ StÄ™chÅ‚y. Here I will just work out how it operates.\n Ising hamiltonians are the easiest to map to quantum circuits and learning how to encode them will help us with more complicated hamiltonians.\n using LinearAlgebra: I, tr  # Computational basis ğŸ = [1,0] ğŸ = [0,1]  X = [0 1; 1 0] Z = [1 0; 0 -1] # we measure in Z basis  H = [1 1; 1 -1]/âˆš2 p = H * ğŸ # = |+âŸ© m = H * ğŸ # = |-âŸ©  Rotate qubits to measure other Pauli matrices (than $\\sigma_x$) As an example, if we measure in the Z basis its not possible to distinguish between $|+\\rangle$ and $|-\\rangle$.\n@info \u0026quot;âŸ¨+|Z|+âŸ© â‰ˆ âŸ¨-|Z|-âŸ©\u0026quot;, p'*Z*p â‰ˆ m'* Z*m  â”Œ Info: (\u0026quot;âŸ¨+|Z|+âŸ© â‰ˆ âŸ¨-|Z|-âŸ©\u0026quot;, true)  Rotating the basis in a certain way allows us to unequivocally distinguish them.\nRy(Î¸) = [cos(Î¸/2) -sin(Î¸/2); sin(Î¸/2) cos(Î¸/2)]  @assert Ry(Ï€/2)*p â‰ˆ ğŸ @assert Ry(Ï€/2)*m â‰ˆ ğŸ  p_rot = Ry(-Ï€/2)*p m_rot = Ry(-Ï€/2)*m @info \u0026quot;âŸ¨+|Z|Ry(-Ï€/2)|+âŸ© â‰ˆ âŸ¨-|Z|Ry(-Ï€/2)|-âŸ©\u0026quot;, p_rot'*Z*p_rot â‰ˆ m_rot'* Z*m_rot @info \u0026quot;Outcome of âŸ¨+|Z|Ry(-Ï€/2)|+âŸ© = \u0026quot;, p_rot'*Z*p_rot @info \u0026quot;Outcome of âŸ¨-|Z|Ry(-Ï€/2)|-âŸ© = \u0026quot;, m_rot'* Z*m_rot  â”Œ Info: (\u0026quot;âŸ¨+|Z|Ry(-Ï€/2)|+âŸ© â‰ˆ âŸ¨-|Z|Ry(-Ï€/2)|-âŸ©\u0026quot;, false) â”Œ Info: (\u0026quot;Outcome of âŸ¨+|Z|Ry(-Ï€/2)|+âŸ© = \u0026quot;, 0.9999999999999998) â”Œ Info: (\u0026quot;Outcome of âŸ¨-|Z|Ry(-Ï€/2)|-âŸ© = \u0026quot;, -0.9999999999999998)  The solution is to apply\n $R_y(âˆ’\\pi/2)$ if Hamiltonian has $\\hat{X}$ $R_x(\\pi/2)$ if Hamiltonian has $\\hat{Y}$ $I$ if Hamiltonian has $\\hat{Z}$  before measurement. Consequently, the circuit will be different for each Pauli matrix.\nDivide the Hamiltonian into single Pauli terms ğ“—â‚ = 2Z ğ“—â‚‚ = X ğ“—â‚ƒ = I(2) ğ“— = ğ“—â‚ + ğ“—â‚‚ + ğ“—â‚ƒ @assert ğ“— â‰ˆ [3 1; 1 -1]  Initial state We use a parametrized initial wavefunction for reasons that will be explained later but you can already guess that we will do a variational search.\n# Ansatz will be Ry(Î¸)*ğŸ ansatz(Î¸) = Ry(Î¸)*ğŸ  A circuit for each term function vqe(Î¸, verbose=false) verbose \u0026amp;\u0026amp; @info \u0026quot;Î¸ = $(Î¸[1])\u0026quot; # Circuit for ğ“—â‚: Ïˆ ---[ hâ‚ )=== Ïˆ = ansatz(Î¸[1]) hâ‚ = 2Ïˆ' * Z * Ïˆ verbose \u0026amp;\u0026amp; @info \u0026quot; Eâ‚ = $hâ‚\u0026quot; # Circuit for ğ“—â‚‚: Ïˆ ---[ Ry ]---[ hâ‚‚ )=== Ïˆ = Ry(-Ï€/2)*ansatz(Î¸[1]) hâ‚‚ = Ïˆ' * Z * Ïˆ verbose \u0026amp;\u0026amp; @info \u0026quot; Eâ‚‚ = $hâ‚‚\u0026quot; # Circuit for ğ“—â‚ƒ: hâ‚ƒ = 1 verbose \u0026amp;\u0026amp; @info \u0026quot; Eâ‚ƒ = $hâ‚ƒ\u0026quot; verbose \u0026amp;\u0026amp; @info \u0026quot; âŸ¨Ïˆ($Î¸[1])|ğ“—|Ïˆ($Î¸[1])âŸ© = $(hâ‚ + hâ‚‚ + hâ‚ƒ)\u0026quot; hâ‚ + hâ‚‚ + hâ‚ƒ end  For two single parameter values we have\nvqe([0],true) vqe([Ï€],true)  â”Œ Info: Î¸ = 0 â”Œ Info: Eâ‚ = 2.0 â”Œ Info: Eâ‚‚ = 2.220446049250313e-16 â”Œ Info: Eâ‚ƒ = 1 â”Œ Info: âŸ¨Ïˆ([0][1])|ğ“—|Ïˆ([0][1])âŸ© = 3.0 â”Œ Info: Î¸ = Ï€ â”Œ Info: Eâ‚ = -2.0 â”Œ Info: Eâ‚‚ = -2.220446049250313e-16 â”Œ Info: Eâ‚ƒ = 1 â”Œ Info: âŸ¨Ïˆ([Ï€][1])|ğ“—|Ïˆ([Ï€][1])âŸ© = -1.0  using Optim  result = optimize(vqe, [0.0], BFGS())   * Status: success * Candidate solution Final objective value: -1.236068e+00 * Found with Algorithm: BFGS * Convergence measures |x - x'| = 6.65e-06 â‰° 0.0e+00 |x - x'|/|x'| = 2.48e-06 â‰° 0.0e+00 |f(x) - f(x')| = 4.94e-11 â‰° 0.0e+00 |f(x) - f(x')|/|f(x')| = 4.00e-11 â‰° 0.0e+00 |g(x)| = 1.37e-11 â‰¤ 1.0e-08 * Work counters Seconds run: 0 (vs limit Inf) Iterations: 4 f(x) calls: 10 âˆ‡f(x) calls: 10  Î¸_opt = Optim.minimizer(result)[1] energy_opt = Optim.minimum(result) @info \u0026quot;VQE: Î¸* = $Î¸_opt, E* = $energy_opt\u0026quot;  â”Œ Info: VQE: Î¸* = -2.6779450445907376, E* = -1.2360679774997898  More advanced hamiltonians Fermionic operators can be transformed into Ising-type hamiltonians in several ways. The most common are the Jordan-Wigner and Bravyi-Kitaev transformations.\nIn this example we only had a single qubit but it can be extended to multiple qubits.\n","date":1609235648,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1609235648,"objectID":"3e01e3502348d5b22101423537134655","permalink":"https://zyth0s.github.io/project/variational-quantum-eigensolver-for-ising-hamiltonians/","publishdate":"2020-12-29T09:54:08.222Z","relpermalink":"/project/variational-quantum-eigensolver-for-ising-hamiltonians/","section":"project","summary":"Jupyter notebook here.\nVariational Quantum Eigensolver (VQE) algorithm is a quantum realization of Ritz\u0026rsquo;s variational method.\nA more lengthy explanation is given by MichaÅ‚ StÄ™chÅ‚y. Here I will just work out how it operates.","tags":["Quantum Computing"],"title":"Variational Quantum Eigensolver for Ising Hamiltonians","type":"project"},{"authors":null,"categories":null,"content":"This is an attempt to reproduce Psi4NumPy with Julia.\n","date":1609159169,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1609159169,"objectID":"053811e70d7614d3d39cb6cce6c2be97","permalink":"https://zyth0s.github.io/project/psi4julia/","publishdate":"2020-12-28T12:39:29.992Z","relpermalink":"/project/psi4julia/","section":"project","summary":"This is an attempt to reproduce Psi4NumPy with Julia.","tags":null,"title":"Psi4julia","type":"project"},{"authors":null,"categories":["Condensed Matter"],"content":"The tutorial is also hosted in GitHub.\nTable of Contents  Two site chain     Three site chain Three site ring     Large homoatomic ring     A generic tight binding procedure Large chain     Discrete chain     Two sites per cell with $s$ orbitals     Two sites per cell with $s$ and $p$ orbitals Two dimensional lattice   Tight binding is a method that expands orbitals as a linear combination of atomic orbitals, like the method with the corresponding acronym, LCAO. Sometimes they are refered as being the same, but let me note some differences between them. First, LCAO often encompasses large expansions to achieve chemical accuracy. Tight-binding, however, is more commonly used with a minimal basis. Another difference is the reduction to an active orbital space. The set of orbitals is reduced in tight binding to a subset around the chemical potential, e.g. only Ï€ orbitals in a polymer chain. In that sense, it is more similar to HÃ¼ckel\u0026rsquo;s method. Also, frequently, only interactions with the first coordination shells are included. And finally, electron-electron interactions are commonly neglected in tight-binding. These differences stem from being two similar methods used by different communities with different purposes. Tight-binding is often a model to approximate the electronic structure of large solid state systems, and LCAO is a good first approximation to accurately approximate the electronic structure of small molecular systems. The chemist tries to predict mainly reactions for whose accurate predictions are needed whereas the physicist tries to explain features of materials in a search for new physics laws.\nMost of the material of this article is inspired by a curse given by Prof. Tjeng Hao during 2020 pandemic lockdown.\nWe load linear algebra and plotting libraries first.\nusing Pkg; Pkg.add(\u0026quot;Measures\u0026quot;) Pkg.add(\u0026quot;Parameters\u0026quot;)  using LinearAlgebra using Plots using Measures: mm using Parameters import PyPlot pyplt = PyPlot mpl = PyPlot.matplotlib pyplt.matplotlib.style.reload_library() pyplt.matplotlib.style.use(\u0026quot;sci\u0026quot;) mpl.use(backend=\u0026quot;Qt5Agg\u0026quot;)  To plot the density of states we need to broaden/smear the spectral lines. Note that the line shape observed experimentally is broadened by the Doppler effect among other phenomena.\ninclude(\u0026quot;dos_broadening.jl\u0026quot;)  In this tutorial we will neglect electron-electron interactions, focusing only on kinetic electron energy and electron-external potential. Sites refers to atoms in a lattice. Besides, we sometimes name sites rather than atomic orbitals because we think of (atomic) orbitals as being very localized around a site. This also helps distinguishing atomic from molecular/crystal orbitals, becoming simply sites and orbitals/states, respectively. Note that atomic orbitals are just used to contruct true eigenstates of the hamiltonian considered but the earlier are no proper states. They are used because functions with similar shape to eigenfunctions of the Hydrogen atom hamiltonian are a good first approximation to eigenfunctions of other hamiltonians.\n Two site chain graph LR; 1((1))---2((2));  A chain of two sites, one site with reference energy $0$ and the other $\\Delta$ higher, has a simple tight binding hamiltonian\nfunction buildH2(Î”,t) # Heâº [ 0 t; t Î”] end  where $t$ is the hopping parameter.\n# Two atomic orbitals at sites 1 and 2 t = 0; Î” = 2 println(\u0026quot;A.1. t = $t, Î” = $Î”\u0026quot;) H = buildH2(Î”,t) es, vs = eigen(H) for i in 1:length(es) println(\u0026quot;Eigenstate with E = $(es[i]) and vector $(vs[i,:])\u0026quot;) end  A.1. t = 0, Î” = 2 Eigenstate with E = 0.0 and vector [1.0, 0.0] Eigenstate with E = 2.0 and vector [0.0, 1.0]  Example 1 t = 2; Î” = 0 println(\u0026quot;A.2. t = $t, Î” = $Î”\u0026quot;) H = buildH2(Î”,t) es, vs = eigen(H) for i in 1:length(es) println(\u0026quot;Eigenstate with E = $(es[i]) and vector $(vs[i,:])\u0026quot;) end  A.2. t = 2, Î” = 0 Eigenstate with E = -2.0 and vector [-0.7071067811865475, 0.7071067811865475] Eigenstate with E = 2.0 and vector [0.7071067811865475, 0.7071067811865475]  Example 2 t = 1; Î” = 10 println(\u0026quot;A.3. t \u0026lt;\u0026lt; Î”; t = $t, Î” = $Î”\u0026quot;) H = buildH2(Î”,t) es, vs = eigen(H) for i in 1:length(es) println(\u0026quot;Eigenstate with E = $(es[i]) and vector $(vs[i,:])\u0026quot;) end  A.3. t \u0026lt;\u0026lt; Î”; t = 1, Î” = 10 Eigenstate with E = -0.09901951359278481 and vector [-0.9951333266680701, 0.09853761796664214] Eigenstate with E = 10.099019513592786 and vector [0.09853761796664214, 0.9951333266680701]   Three site chain graph LR; 1((1))---2((2))---3((3));  Three sites (with open boundary) and site energies $0$, $\\Delta_1$, $\\Delta_2$, hoping constants $t$\nfunction buildHchain3(Î”1,Î”2,t12,t23) [ 0 t12 0; t12 Î”1 t23; 0 t23 Î”2] end   Three site ring If the sites are forming a ring (periodic boundary conditions) there are hoping matrix elements at the lower-left and upper-right corners. The hamiltonian matrix is circulant rather than Toeplitz-like.\nfunction buildHring3(Î”1,Î”2,t12,t13,t23) [ 0 t12 t13; t12 Î”1 t23; t13 t23 Î”2] end  Example: 3 centers 1 electron println(\u0026quot;B.1. Î”â‚ = 2, Î”â‚‚ = 5, tâ‚â‚‚ = 1, tâ‚â‚ƒ = 2, tâ‚‚â‚ƒ = 1\u0026quot;) H = buildHring3(2,5,1,2,1) es, vs = eigen(H) for i in 1:length(es) println(\u0026quot;Eigenstate with E = $(es[i]) and vector $(vs[i,:])\u0026quot;) end  B.1. Î”â‚ = 2, Î”â‚‚ = 5, tâ‚â‚‚ = 1, tâ‚â‚ƒ = 2, tâ‚‚â‚ƒ = 1 Eigenstate with E = -0.8460273610588649 and vector [-0.932296868605906, -0.12026011521212177, 0.34111589449450974] Eigenstate with E = 1.7430864995096744 and vector [0.22929082064416684, -0.9258926649319276, 0.3002473856565238] Eigenstate with E = 6.102940861549199 and vector [0.2797289194129681, 0.35813444083810214, 0.890781372688963]   Large homoatomic ring A large homoatomic ring (circulant matrix)\nfunction buildHring(t,N=1001) H = SymTridiagonal(zeros(N),t*ones(N-1)) H = convert(Matrix,H) H[N,1] = H[1,N] = t H end  Example: without impurity graph LR; 1((1))---2((2))---3((3))---4((4))---5((...))---6((1))---7((...));  t = 2.5; N = 1001 println(\u0026quot;C.1. Ring with $N sites and t = $t\u0026quot;) H = buildHring(t,N) es, vs = eigen(H) W = 2abs(t) # half-bandwith band = scatter(es, xlabel=\u0026quot;Site\u0026quot;, ylabel=\u0026quot;Energy\u0026quot;,ms=2,leg=false, ylims=(-W-1,W+1))  C.1. Ring with 1001 sites and t = 2.5  e_dos, dos = dos_broadening(es) dos = plot(dos,e_dos, ylabel=\u0026quot;Energy\u0026quot;, xlabel=\u0026quot;DOS\u0026quot;,leg=false, ylims=(-W-1,W+1)) l = @layout [ a b] plot(band,dos,layout=l) savefig(\u0026quot;../figures/C.1_bandos_ring_t=$(t)_N=$(N)_E0=0.pdf\u0026quot;)  Example: with an impurity graph LR; 1((1))---2((2))---3((3))---4((4))---5((...))---6((1))---7((...)); style 3 fill:#bbf,stroke:#f66,stroke-width:1px,color:#fff  # If the ring has an impurity in the middle function buildHring_impurity(t,Î”,N=1001) H = SymTridiagonal(zeros(N),t*ones(N-1)) H = convert(Matrix,H) H[N,1] = H[1,N] = t H[NÃ·2,NÃ·2] = Î” H end  t = 2.5; N = 1001; Î” = -2; impuritysite = NÃ·2 println(\u0026quot;C.2. Ring with $N sites with t = $t, impurity at $impuritysite Î” = $Î”\u0026quot;) H = buildHring_impurity(t,Î”,N) es, vs = eigen(H) println(\u0026quot;Impurity state with E = $(es[1])\u0026quot;) W = 2abs(t) # half-bandwith band = scatter(es, xlabel=\u0026quot;Site\u0026quot;, ylabel=\u0026quot;Energy\u0026quot;,ms=2,leg=false, ylims=(-W-1,W+1)) e_dos, dos = dos_broadening(es) dos = plot(dos,e_dos, ylabel=\u0026quot;Energy\u0026quot;, xlabel=\u0026quot;DOS\u0026quot;,leg=false, ylims=(-W-1,W+1)) l = @layout [ a b] plot(band,dos,layout=l) #savefig(\u0026quot;../figures/C.2_bandos_ring_t=$(t)_N=$(N)_E0=0_middleimpurity=$Î”.pdf\u0026quot;)  C.2. Ring with 1001 sites with t = 2.5, impurity at 500 Î” = -2 Impurity state with E = -5.385164807134497  plot(vs[:,1].*vs[:,1],xlims=(490,510), label=\u0026quot;Bound state\u0026quot;, ylabel=\u0026quot;Probability\u0026quot;,xlabel=\u0026quot;Site\u0026quot;, title=\u0026quot;Contribution of site orbitals to impurity state\u0026quot;) #savefig(\u0026quot;../figures/C.2_boundstate_ring_t=$(t)_N=$(N)_E0=0_middleimpurity=$Î”.pdf\u0026quot;)   A generic tight binding procedure Generic function to solve tight-binding hamiltonian, and plot bands, DOS, and PDOS.\nfunction tight_binding(hamiltonianConstructor::Function,params,name) @unpack t, N, Î”, impuritysite = params if ismissing(Î”) println(\u0026quot;$name with $N sites with t = $t\u0026quot;) else println(\u0026quot;$name with $N sites with t = $t, impurity at $impuritysite, Î” = $Î”\u0026quot;) end H = hamiltonianConstructor(params...) es, vs = eigen(H) W = 2abs(t) # half-bandwith 1D emargin = 1.5 println(\u0026quot;Lowest energy state with E = $(es[1])\u0026quot;, es[1]\u0026lt;-W ? \u0026quot; (surface state)\u0026quot; : \u0026quot;\u0026quot;) band = scatter(es, xlabel=\u0026quot;Site\u0026quot;, ylabel=\u0026quot;Energy\u0026quot;,ms=2,leg=false, ylims=(-W-emargin,W+emargin)) e_dos, dos = dos_broadening(es) dos = plot(dos,e_dos, xlabel=\u0026quot;DOS\u0026quot;,leg=false, xlims=(0,1),ylims=(-W-emargin,W+emargin)) e_pdos1, pdos1 = dos_broadening(es,vs[1,:].*vs[1,:]) pdos = plot(pdos1,e_pdos1,label=\u0026quot;Site 1\u0026quot;, ylims=(-W-emargin,W+emargin)) e_pdos500, pdos500 = dos_broadening(es,vs[NÃ·2,:].*vs[NÃ·2,:]) pdos = plot!(pdos, pdos500, e_pdos500, label=\u0026quot;Site $(NÃ·2)\u0026quot;, xlims=(0,0.0013), xlabel=\u0026quot;PDOS\u0026quot;) l = @layout [ a b c] plot(band,dos,pdos, layout=l, size=(1200,400), left_margin=5mm,bottom_margin=5mm, right_margin=0mm,top_margin=0mm) #if ismissing(impuritysite) # savefig(\u0026quot;../figures/$(name)_t=$(t)_N=$(N)_E0=0.pdf\u0026quot;) #else # savefig(\u0026quot;../figures/$(name)_t=$(t)_N=$(N)_E0=0_@$(impuritysite)=$Î”.pdf\u0026quot;) #end end   Large chain A long chain considering only nearest-neighbors hopings, all equal, with the possibility of having an impurity in the middle\nfunction buildHchain_tridiag(t,N=1001) H = SymTridiagonal(zeros(N),t*ones(N-1)) end function buildHchain(t,N=1001,Î”=missing,impuritysite=missing) if ismissing(Î”) # homoatomic chain return buildHchain_tridiag(t,N) end H = SymTridiagonal(zeros(N),t*ones(N-1)) H = convert(Matrix,H) H[impuritysite,impuritysite] = Î” H end  We will explore Schokley/Tamm surface states\nExample D.1: Chain without impurity graph LR; 1((1))---2((2))---3((3))---4((4))---5((...))---6((N));  name = \u0026quot;D.1. Chain\u0026quot; params = (t=2.5,N=1001,Î”=missing,impuritysite=missing) tight_binding(buildHchain,params,name)  D.1. Chain with 1001 sites with t = 2.5 Lowest energy state with E = -4.999975424409872  Example D.2: Impurity in the middle graph LR; 1((1))---2((...))---3((N/2-1))---4((N/2))---5((N/2+1))---6((...))---7((N)); style 4 fill:#bbf,stroke:#f66,stroke-width:1px,color:#fff  name = \u0026quot;D.2. Chain\u0026quot; params = (t=2.5,N=1001,Î”=-2,impuritysite=500) tight_binding(buildHchain,params,name)  D.2. Chain with 1001 sites with t = 2.5, impurity at 500, Î” = -2 Lowest energy state with E = -5.385164807134504 (surface state)  Example D.3: Impurity at the surface graph LR; 1((1))---2((...))---3((N/2-1))---4((N/2))---5((N/2+1))---6((...))---7((N)); style 1 fill:#bbf,stroke:#f66,stroke-width:1px,color:#fff  name = \u0026quot;D.3. Chain\u0026quot; params = (t=2.5,N=1001,Î”=-2,impuritysite=1) tight_binding(buildHchain,params,name)  D.3. Chain with 1001 sites with t = 2.5, impurity at 1, Î” = -2 Lowest energy state with E = -4.99997561943913  Example D.4: Impurity at the surface, strong impurity graph LR; 1((1))---2((...))---3((N/2-1))---4((N/2))---5((N/2+1))---6((...))---7((N)); style 1 fill:#bbf,stroke:#f66,stroke-width:1px,color:#fff  name = \u0026quot;D.4. Chain\u0026quot; params = (t=2.5,N=1001,Î”=-4,impuritysite=1) tight_binding(buildHchain,params,name)  D.4. Chain with 1001 sites with t = 2.5, impurity at 1, Î” = -4 Lowest energy state with E = -5.562499999999997 (surface state)  Finite effects are also interesting\nDiscrete chain graph LR; 1((1))---2((2))---3((3))---4((4))---5((5))---6((...))---9((9)); style 1 fill:#bbf,stroke:#f66,stroke-width:1px,color:#fff  Example E.1: Weak impurity name = \u0026quot;E.1. Finite Chain\u0026quot; params = (t=2.5,N=9,Î”=-2,impuritysite=1) tight_binding(buildHchain,params,name)  E.1. Finite Chain with 9 sites with t = 2.5, impurity at 1, Î” = -2 Lowest energy state with E = -4.853039707148026  Example E.2: Strong impurity name = \u0026quot;E.2. Finite Chain\u0026quot; params = (t=2.5,N=9,Î”=-4,impuritysite=1) tight_binding(buildHchain,params,name)  E.2. Finite Chain with 9 sites with t = 2.5, impurity at 1, Î” = -4 Lowest energy state with E = -5.562184783729448 (surface state)   Two sites per cell with $s$ orbitals function tight_binding_1D_2sites(a,Î”â‚â‚‚,t) # 1D chain/ring with 2 sites per unit cell, s orbitals b = 2a # unit cell with two sites Îµ1 = 0 # without loss of generality energy reference at 0 Îµ2 = Î”â‚â‚‚ kpath = range(-Ï€/b,Ï€/b,length=100) Enk = zeros(2,length(kpath)) for (ik,k) in enumerate(kpath) H_k = [ Îµ1 2t*cos(k*a); 2t*cos(k*a) Îµ2 ] e, vs = eigen(H_k) Enk[:,ik] = e end plot(kpath/Ï€,[Enk[1,:], Enk[2,:]], label=[\u0026quot;Ground state\u0026quot; \u0026quot;Excited state\u0026quot;], xlabel=\u0026quot;k pi/a\u0026quot;, ylabel=\u0026quot;Energy\u0026quot;, leg = :inside, ) #savefig(\u0026quot;../figures/1d_2sites.pdf\u0026quot;) end  Example tight_binding_1D_2sites(1,2,2) # a, Î”â‚â‚‚, t   Two sites per cell with $s$ and $p$ orbitals function tight_binding_1D_2sites_sp_orbs(a,Î”â‚â‚‚,t) # 1D chain/ring with 2 sites per unit cell, sp orbitals # Redefined Ïˆpk = i 1/âˆšN * âˆ‘Râ‚‚ exp(ikRâ‚‚) Ï•p(r-Râ‚‚) to have a real matrix b = 2a # unit cell with two sites Îµs = Î”â‚â‚‚ Îµp = 0 # without loss of generality energy reference at 0 kpath = range(-Ï€/b,Ï€/b,length=100) Enk = zeros(2,length(kpath)) for (ik,k) in enumerate(kpath) H_k = [ Îµs -2t*sin(k*a); -2t*sin(k*a) Îµp ] e, vs = eigen(H_k) Enk[:,ik] = e end plot(kpath/Ï€,[Enk[1,:], Enk[2,:]], label=[\u0026quot;p state\u0026quot; \u0026quot;s state\u0026quot;], xlabel=\u0026quot;k pi/a\u0026quot;, ylabel=\u0026quot;Energy\u0026quot;, leg = :right, ) #savefig(\u0026quot;../figures/1d_2sites_sp_orbs.pdf\u0026quot;) end  tight_binding_1D_2sites_sp_orbs(1,2,2) # a, Î”â‚â‚‚, t   Two dimensional lattice function tight_binding_2D(a,b,Î”â‚â‚‚,ta,tb) # 2D rectangular lattice with 1 site per unit cell, s orbitals @assert a == b # does not handle rectangular with analytic formula @assert Î”â‚â‚‚ == 0 # does not handle â‰  Îµ with analytic formula Îµ1 = 0 # without loss of generality energy reference at 0 Îµ2 = Î”â‚â‚‚ Hamiltonian(kx,ky) = [ Îµ1 2ta*cos(kx*a) + 2tb*cos(ky*b); 2ta*cos(kx*a) + 2tb*cos(ky*b) Îµ2 ] # ............................ # Band plot nkpts = 100 kpath = zeros(2,3nkpts) kpath[1, 1:nkpts] = range(0,Ï€/a,length=nkpts) kpath[2, 1:nkpts] .= 0 # kpath[1,(nkpts+1):2nkpts] .= Ï€/a kpath[2,(nkpts+1):2nkpts] = range(0,Ï€/b,length=nkpts) # kpath[1,(2nkpts+1):3nkpts] = range(Ï€/a,0,length=nkpts) kpath[2,(2nkpts+1):3nkpts] = range(Ï€/b,0,length=nkpts) Enk = zeros(2,3nkpts) for ik in 1:3nkpts kx = kpath[1,ik] ky = kpath[2,ik] H_k = Hamiltonian(kx,ky) e, vs = eigen(H_k) #Enk[:,ik] = e # FIXME Enk[1,ik] = Îµ1 + Îµ2 - 2abs(ta)*cos(kx*a) - 2abs(tb)*cos(ky*b) # analytic formula end #plot(1:3nkpts,[Enk[1,:],Enk[2,:]], #plot(1:3nkpts,Enk[1,:], # label=[\u0026quot;Ground state\u0026quot; \u0026quot;Excited state\u0026quot;], # xlabel=\u0026quot;kpath/pi\u0026quot;, ylabel=\u0026quot;Energy\u0026quot;, # leg = :inside, # ) #savefig(\u0026quot;2d_1sites.pdf\u0026quot;) fig = pyplt.figure() fig.set_dpi(260) ax = fig.add_subplot(111) ax.plot(1:3nkpts,Enk[1,:], label=\u0026quot;Ground state\u0026quot;) ax.xaxis.set_major_locator(mpl.ticker.MultipleLocator(100)) ax.set_xticklabels([\u0026quot;d\u0026quot;,\u0026quot;(0,0)T\u0026quot;, \u0026quot;(1,0)T\u0026quot;, \u0026quot;(1,1)T\u0026quot;, \u0026quot;(0,0)T\u0026quot;]) ax.set_xlim(0,3nkpts) ax.set_ylim(-2abs(ta)-2abs(tb),2abs(ta)+2abs(tb)) ax.grid(true) ax.set_xlabel(\u0026quot;(kx,ky)T pi/a\u0026quot;) ax.set_ylabel(\u0026quot;Energy\u0026quot;) fig.tight_layout(pad=0.1) pyplt.savefig(\u0026quot;../figures/2d_1sites.pdf\u0026quot;) # .......................................................... # BZ integration nmesh = 101 Enk = zeros(2,nmesh,nmesh) kxrange = range(-Ï€/a,Ï€/a,length=nmesh) kyrange = range(-Ï€/b,Ï€/b,length=nmesh) for (ikx,kx) in enumerate(kxrange), (iky,ky) in enumerate(kyrange) H_k = Hamiltonian(kx,ky) #e, vs = eigen(H_k) # FIXME ##_,_,eschur = schur(H_k) Enk[1,ikx,iky] = Îµ1 + Îµ2 - 2abs(ta)*cos(kx*a) - 2abs(tb)*cos(ky*b) # analytic result a = b; ... #if abs(kx) + abs(ky) \u0026lt; pi/a # Enk[:,ikx,iky] = e #else # Enk[:,ikx,iky] = reverse(e) #end #isapprox(e[1] , Îµ1 + Îµ2 + 2ta*cos(kx*a) + 2tb*cos(ky*b), atol=1e-1) || error(\u0026quot;wrong eigenvalue $(e[1]) â‰  $(Îµ1 + Îµ2 + 2ta*cos(kx*a) + 2tb*cos(ky*b))\u0026quot;) #@show kx, ky #println(e[1],\u0026quot; \u0026quot;, e[2], \u0026quot; \u0026quot;, Îµ1 + Îµ2 - 2abs(ta)*cos(kx*a) - 2abs(tb)*cos(ky*b)) #e[1], e[2] = e[2], e[1] end fig = pyplt.figure() fig.set_dpi(260) ax = fig.add_subplot(111) ax.set_aspect(\u0026quot;equal\u0026quot;) cont = ax.contourf(kxrange./Ï€,kyrange./Ï€,Enk[1,:,:], levels=15) #cont = ax.plot_surface(kxrange./Ï€,kyrange./Ï€,Enk[1,:,:]) #cont = ax.imshow(Enk[1,:,:],extent=(-1,1,-1,1)) # Set axis labels ax.set_xlabel(\u0026quot;kx pi/a\u0026quot;) ax.set_ylabel(\u0026quot;ky pi/b\u0026quot;) pyplt.colorbar(cont,format=\u0026quot;%+3.1f\u0026quot;) fig.tight_layout(pad=0.1) pyplt.savefig(\u0026quot;../figures/2d_1sites_contour.pdf\u0026quot;) end  tight_binding_2D(1,1,0,1,1) # a, b, Î”â‚â‚‚, ta, tb #tight_binding_2D(10,5,2,0.5,1) # a, b, Î”â‚â‚‚, ta, tb  ","date":1609158055,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1609158055,"objectID":"033c8e3f428dfa7dac7f4dde736ce55f","permalink":"https://zyth0s.github.io/project/tight-binding-tutorial/","publishdate":"2020-12-28T12:20:55.134Z","relpermalink":"/project/tight-binding-tutorial/","section":"project","summary":"The tutorial is also hosted in GitHub.\nTable of Contents  Two site chain     Three site chain Three site ring     Large homoatomic ring     A generic tight binding procedure Large chain     Discrete chain     Two sites per cell with $s$ orbitals     Two sites per cell with $s$ and $p$ orbitals Two dimensional lattice   Tight binding is a method that expands orbitals as a linear combination of atomic orbitals, like the method with the corresponding acronym, LCAO.","tags":["Condensed Matter"],"title":"Tight binding tutorial","type":"project"},{"authors":null,"categories":null,"content":"We briefly discuss how to eigendecompose a symmetric square matrix, and check some of its properties.\nNote about notation:\n vectors are bold lowercase, like $\\mathbf{u,v}$. matrices are bold uppercase, like $\\mathbf{A,B,C}$. scalars are lowercase, like $x,y,z$. ' means (i) the complex conjugate for scalars, or (ii) the (conjugate) transpose for vectors/matrices.  using LinearAlgebra: eigen, Diagonal, I, det, rank  Given an ordered basis every linear mapping has a unique transformation matrix. A way to characterize the matrix representation of the linear mapping is by how it transforms vectors. It turns out that we can find a set of special vectors that are just scaled by some eigenvalue when we apply the linear mapping to them.\nLets take a $4 \\times 4$ matrix,\nA = rand(4,4)  that is symmetric (or hermitic if elements were complex)\nA = (A + A')/2  A $4 \\times 4$ matrix has 4 eigenvalues $(e_1,e_2,e_3,e_4)$ and 4 respective eigenvectors $(\\mathbf{v}_1,\\mathbf{v}_2,\\mathbf{v}_3,\\mathbf{v}_4)$\ne, U = eigen(A) # solves $Av = ev$  eigen returns the eigenvalues in a vector e and the eigenvectors as columns of a matrix U. E.g. the first eigenvalue is $e_1 =$ e[1] and the first eigenvector is $\\mathbf{v}_1 =$ U[:,1]. Note that eigenvalues are ordered in descending order and eigenvectors reflect this reordering.\nWe can check that the secular equation $|\\mathbf{A} - e_i\\mathbf{I}| = 0$ is satisfied (for each eigenvalue)\nfor i in 1:4 isapprox( det(A - e[i]*I), 0.00, atol=1e-4) || error(\u0026quot;Secular equation $i not satisfied\u0026quot;) end  The corresponding eigenvectors satisfy $(\\mathbf{A} - e_i\\mathbf{I})\\mathbf{v} = \\mathbf{0}$\nfor i in 1:4 isapprox( (A - e[i]*I)*U[:,i], fill(0.00,4), atol=1e-4) || error(\u0026quot;a) Eigenvalue equation $i not satisfied\u0026quot;) end  or equivalently $\\mathbf{A}\\mathbf{v} = e_i\\mathbf{v}$\nfor i in 1:4 isapprox( A*U[:,i], e[i]*U[:,i], atol=1e-4) || error(\u0026quot;b) Eigenvalue equation $i not satisfied\u0026quot;) end   If $\\mathbf{A}$ is symmetric, thus $\\mathbf{U}$ is orthonormal and $\\mathbf{U}' = \\mathbf{U}^{-1}$ If $\\mathbf{A}$ is hermitic, thus $\\mathbf{U}$ is unitary and $\\mathbf{U}' = \\mathbf{U}^{-1}$  In both cases it can be described as a similarity transformation $$ \\mathbf{A} = \\mathbf{U} \\mathbf{D} \\mathbf{U}^{-1} = \\mathbf{U} \\mathbf{D} \\mathbf{U}' $$ where $\\mathbf{D}$ is a diagonal matrix with the eigenvalues as diagonal elements. Therefore, $\\mathbf{D}$ is the matrix that diagonalizes $\\mathbf{A}$. $\\mathbf{A}$ and $\\mathbf{D}$ are said to be similar matrices.\nA â‰ˆ U * Diagonal(e) * U' || error(\u0026quot;Not a similarity transformation\u0026quot;)  A similarity transformation is also a conformal mapping. A matrix $\\mathbf{W}$ encoding a crystallographic symmetry operation is an isometry if $$ \\mathbf{G} \\approx \\mathbf{W} \\mathbf{G} \\mathbf{W}' $$ where $\\mathbf{G}$ is the metric tensor.\n","date":1609154812,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1609154812,"objectID":"118a279d0bb41542fae15802b5dfb513","permalink":"https://zyth0s.github.io/post/spectral-decomposition-with-julia/","publishdate":"2020-12-28T11:26:52.193Z","relpermalink":"/post/spectral-decomposition-with-julia/","section":"post","summary":"We briefly discuss how to eigendecompose a symmetric square matrix, and check some of its properties.\nNote about notation:\n vectors are bold lowercase, like $\\mathbf{u,v}$. matrices are bold uppercase, like $\\mathbf{A,B,C}$.","tags":null,"title":"Spectral decomposition with Julia","type":"post"},{"authors":["Daniel MenÃ©ndez Crespo"],"categories":["Solar Dynamics"],"content":"A script to simulate planet motion. Plots the solar system at a given moment in time.\n","date":1609143909,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1609143909,"objectID":"b1c355bf6897fe06b5db3c3502ac30d1","permalink":"https://zyth0s.github.io/project/solar-system-simulation/","publishdate":"2020-12-28T08:25:09.886Z","relpermalink":"/project/solar-system-simulation/","section":"project","summary":"A script to simulate planet motion. Plots the solar system at a given moment in time.","tags":["Solar Dynamics"],"title":"Solar System Simulation","type":"project"},{"authors":["Daniel Menendez Crespo"],"categories":["Quantum Computing"],"content":"The tutorial is also hosted in GitHub.\nHave you ever heard of quantum teleportation and wondered what is it exactly? Until very recently I was like you. Even if I received academic formation (including quantum mechanics) I never got past pure astonishment. For instance, once I opened a quantum information book at a public library and I was scared enough to not look further. On the other hand, popular explanations of the concept always fail to give a satisfactory description because they omit the only tool that helps us understand quantum mechanics: math.\nMy perspective changed completely when I encountered Nielsen and Matuschak\u0026rsquo;s Quantum Computing for the very curious fantastic essays. I encourage you to read them also.\nAs you will discover, most of the calculations can be reduced to simple low dimensional matrix operations. It is ideal for tinkering. Furthermore, the whole teleportation protocol can be condensed into a single diagram.\nIn this hands-out tutorial we will cover some of the same concepts with the help of a computer. All code below is written in Julia. Few linear algebra concepts are needed. We use the identity matrix $I_m$, the adjoint operation $A^\\dagger$, the determinant, trace, kroenecker (or tensor) product, and the 2-norm.\nusing LinearAlgebra: I, det, tr, kron, normalize! const âŠ— = kron  Computational quantum basis Digital computers are able to reduce all information to zeros and ones, that is, a bit may be one of the set ${0, 1}$. The measurement of a single bit is described by a probability distribution on the space of possible bits $p: {0,1} \\to [0,1]$. On the other hand, quantum bits belong to a two-dimensional complex vector space $\\mathbb{C}^2$. Measurements give also a probability but draw from a larger space $\\rho_p: \\mathbb{C}^2 \\to [0,1]$.\nNow you might ask how to move data stored in bits to qubits. It turns out that you can map every classical probability distribution to a quantum probability distribution. The resulting distribution is called a density operator, $\\rho_p$. If we think of each element of the bitset ${0,1}$ as a $2 \\times 1$ basis vector, both form an orthonormal basis that spans $\\mathbb{C}^2$.\n $|0\\rangle = [1, 0]^T$ is a column vector representing the classical bit 0 $|1\\rangle = [0, 1]^T$ is a column vector representing the classical bit 1  Column vectors are represented with the bar and right bracket, e.g. $|v\\rangle$, following in Dirac notation. Those two special vectors will be assigned in code to unicode characters that ressemble $0$ and $1$.\nğŸ = [1, 0] # â‰¡ $|0\\rangle$; typeset with \\bfzero ğŸ = [0, 1] # â‰¡ $|1\\rangle$; typeset with \\bfone  The density operator is the $2 \\times 2$ matrix with the classical probabilities arranged along its diagonal, the rest zeros. If we have a classical bit 0 (probability $p=1$ to have $|0\\rangle$ and $p=0$ to have $|1\\rangle$), then the density operator is\nÏğŸ = [1 0; 0 0]  Other way to map classical to quantum probabilities is using the outer product $\\rho_p = \\sum_i p_i |\\psi_i\\rangle \\langle\\psi_i|$\n@assert ÏğŸ â‰ˆ 1ğŸ*ğŸ' + 0ğŸ*ğŸ' # ğŸ has p=1, and ğŸ has p=0 probability  The vector with left angle and bar is a row vector that is the adjoint of the corresponding column vector.\nThe same probability distribution can be arranged as a vector if we had chosen the tensor product instead of the outer product. Instead of a $2 \\times 2$ matrix we have a $4 \\times 1$ vector. Technically, a vector space like $\\mathbb{C}^2$ is isomorphic to $\\mathbb{C} \\otimes \\mathbb{C}$.\n@assert vec(ÏğŸ) â‰ˆ 1ğŸ âŠ— ğŸ + 0ğŸ âŠ— ğŸ  A general qubit A general qubit $|\\psi\\rangle = \\alpha |0\\rangle + \\beta |1\\rangle \\in \\mathbb{C}^2$ is described as a linear combination of the basis vectors and it must satisfy the normalization condition $|\\alpha|^2 + |\\beta|^2 = 1$.\nÎ± = 0.6 Î² = 0.8 @assert Î±^2 + Î²^2 â‰ˆ 1 # normalization contraint (here for Î±, Î² âˆˆ â„) Ïˆ = Î±*ğŸ + Î²*ğŸ @assert Ïˆ â‰ˆ [Î±, Î²] @assert Ïˆ'*Ïˆ â‰ˆ 1 # âŸ¨Ïˆ|ÏˆâŸ© = 1 (normalization again)  Quantum gates Once we have transformed our information to qubits we need to manipulate them to achieve our goal. Those operations are realized with gates that are analogous to classical circuit gates.\nPauli $\\sigma_x$ gate: X == NOT == ---[ X ]--- X = [0 1; 1 0]  @assert X*ğŸ â‰ˆ ğŸ @assert X*ğŸ â‰ˆ ğŸ # By the linearity of matrix multiplication it follows that the matrix acts the # same way as the X on all input states, and so they are the same operation.  @assert X*X' â‰ˆ I(2) # this is a proof of unitariness  X*Ïˆ  2-element Array{Float64,1}: 0.8 0.6  Hadamard gate: H == ---[ H ]--- A Hadamard gate converts a classical bit into a general qubit.\nH = [1 1; 1 -1]./âˆš2  @assert H*ğŸ â‰ˆ [1, 1]./âˆš2 # kinda bonding state @assert H*ğŸ â‰ˆ [1,-1]./âˆš2 # kinda antibonding state # By the linearity of matrix multiplication it follows that the matrix acts the # same way as the Hadamard on all input states, and so they are the same # operation.  @assert H^2 â‰ˆ I(2) # H is idempotent  @assert H*H' â‰ˆ I(2) # this is a proof of unitariness @assert abs(det(H)) â‰ˆ 1 # conservation of particles  Not every matrix is a gate, for instance\nJ = [1 1; 1 1]./âˆš2 @assert (J*J' â‰ˆ I(2)) == false  H X Ïˆ == \u0026mdash;[ X ]\u0026mdash;[ H ]\u0026mdash;\nMeasurement: ---| m )=== In colloquial terms, measurements can be performed by \u0026ldquo;casting the shadow\u0026rdquo; of the qubit state at a place where we can look, that is, our computational quantum basis. The probability of $|u\\rangle$ being $|0\\rangle$ is $\\langle u|0\\rangle\\langle 0|u\\rangle = |\\langle 0|u\\rangle|^2$ or $Tr(\\rho_u |0\\rangle\\langle 0|)$ where $\\rho_u$ is the density operator $|u\\rangle\\langle u|$.\nmeasure(Ïˆ, verbose=false) = begin pğŸ = tr(Ïˆ*Ïˆ' * ğŸ*ğŸ') # â‰¡ âŸ¨Ïˆ|0âŸ©âŸ¨0|ÏˆâŸ© resol. ident pğŸ = tr(Ïˆ*Ïˆ' * ğŸ*ğŸ') # â‰¡ âŸ¨Ïˆ|1âŸ©âŸ¨1|ÏˆâŸ© resol. ident if verbose println(\u0026quot;m = 0 with probability $pğŸ\u0026quot;) println(\u0026quot;m = 1 with probability $pğŸ\u0026quot;) end [pğŸ, pğŸ] end  # _Ïˆ2 ---[ H ]---[ m )=== _Ïˆ = rand([ğŸ,ğŸ]) _Ïˆ2 = H*_Ïˆ # Input state is either (|0âŸ© + |1âŸ©)/âˆš2 or (|0âŸ© - |1âŸ©)/âˆš2 H*_Ïˆ2 |\u0026gt; measure  2-element Array{Float64,1}: 0.0 0.9999999999999996  The state measured is the same as the initial one. That is a consequence of $H$ being idempotent.\nPauli $\\sigma_y$ gate: Y == ---[ Y ]--- Y = [0 -im; im 0] @assert Y*Y' â‰ˆ I(2)  Pauli $\\sigma_z$ gate: Z == ---[ Z ]--- Z = [1 0; 0 -1] @assert Z*Z' â‰ˆ I(2)  General rotation gate Î¸ = Ï€/2  R = [cos(Î¸) -sin(Î¸); sin(Î¸) cos(Î¸)]  2Ã—2 Array{Float64,2}: 6.12323e-17 -1.0 1.0 6.12323e-17  @assert R*R' â‰ˆ I(2)  Rx(Î¸) = cos(Î¸/2)*I(2) - im * sin(Î¸/2)*X Ry(Î¸) = cos(Î¸/2)*I(2) - im * sin(Î¸/2)*Y Rz(Î¸) = cos(Î¸/2)*I(2) - im * sin(Î¸/2)*Z  Multi-qubit states Here again, we can find an analogy with the classical world if we think that we are passing from sets to vector spaces. Whereas classical state spaces are combined with the cartesian product, such as ${0,1} \\times {0,1}$, quantum state spaces are combined with the tensor product, $\\mathbb{C}^2 âŠ— \\mathbb{C}^2$. The classical probability $p: {0,1} \\times {0,1} \\to [0,1]$ on the combined set is a joint probability (the probability of both having 0 in the first and 0 in the second bit, for example). The corresponding density operator is also a joint probability in their tensor product space $\\rho_p: \\mathbb{C}^2 \\otimes \\mathbb{C}^2 \\cong \\mathbb{C}^4 \\to [0,1]$.\nğŸğŸ = ğŸ âŠ— ğŸ ğŸğŸ = ğŸ âŠ— ğŸ ğŸğŸ = ğŸ âŠ— ğŸ ğŸğŸ = ğŸ âŠ— ğŸ  Î³ = 0.8 Î´ = 0.6 Ï• = Î³*ğŸ + Î´*ğŸ  2-element Array{Float64,1}: 0.8 0.6  More generally, if we have single-qubit states Ïˆ and Ï•, then the combined state when the two qubits are put together is just:\nÎ¾ = Ïˆ âŠ— Ï• @assert Î¾ â‰ˆ [Ïˆ[1]*Ï•[1], Ïˆ[1]*Ï•[2], Ïˆ[2]*Ï•[1], Ïˆ[2]*Ï•[2]]  Multi-qubit gates Take the form $G_1 \\otimes G_2 \\otimes \\cdots$.\nControlled-NOT gate (CNOT)  x ---â‹…--- | y ---âŠ•--- x is the control qubit y is the target qubit |x, y âŠ• xâŸ© for short  CNOT = [1 0 0 0; 0 1 0 0; 0 0 0 1; 0 0 1 0] # Also @assert CNOT â‰ˆ cat(I(2), X, dims=(1,2)) #|\u0026gt; Matrix @assert CNOT â‰ˆ ğŸ*ğŸ' âŠ— I(2) + ğŸ*ğŸ' âŠ— X  @assert CNOT*ğŸğŸ â‰ˆ ğŸğŸ @assert CNOT*ğŸğŸ â‰ˆ ğŸğŸ @assert CNOT*ğŸğŸ â‰ˆ ğŸğŸ @assert CNOT*ğŸğŸ â‰ˆ ğŸğŸ  # Apply H to first qubit in a 2d space Hâ‚ = H âŠ— I(2) # Apply H to second qubit in a 2d space Hâ‚‚ = I(2) âŠ— H  4Ã—4 Array{Float64,2}: 0.707107 0.707107 0.0 0.0 0.707107 -0.707107 0.0 0.0 0.0 0.0 0.707107 0.707107 0.0 0.0 0.707107 -0.707107  CNOT*Hâ‚*ğŸğŸ  4-element Array{Float64,1}: 0.7071067811865475 0.0 0.0 0.7071067811865475  Beware, CNOT can change the control qubit!\n# |+-âŸ© pm = H*ğŸ âŠ— H*ğŸ # |--âŸ© mm = H*ğŸ âŠ— H*ğŸ  |0âŸ© ---[ H ]--- |+âŸ©---â‹…--- |-âŸ© | |1âŸ© ---[ H ]--- |-âŸ©---âŠ•--- |-âŸ©  @assert CNOT*pm â‰ˆ mm  Toffoli gate CCNOT Replaces the classical AND gate\n#CCNOT = cat(I(6), [0 1; 1 0], dims=(1,2)) |\u0026gt; Matrix CCNOT = cat(I(4), CNOT, dims=(1,2)) |\u0026gt; Matrix  8Ã—8 Array{Int64,2}: 1 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 1 0  Global phase factor Î¸ = rand() # any real number  0.24805413652694797  G(Î¸) = â„¯^(im*Î¸) * I(2) # global phase factor â„¯^(iÎ¸)  if typeof(Î¸) \u0026lt;: Real @assert G(Î¸)*G(Î¸)' â‰ˆ I(2) @info \u0026quot;A matrix changing the global phase factor is unitary.\u0026quot; end  â”Œ Info: A matrix changing the global phase factor is unitary.  @info \u0026quot;Changing the phase does not affect the measurement.\u0026quot; @assert G(rand())*ğŸ |\u0026gt; measure â‰ˆ measure(ğŸ)  â”Œ Info: Changing the phase does not affect the measurement.  Other gates S = [ 1 0; 0 im] T = [ 1 0; 0 â„¯^(im*Ï€/4)] #Y = [ 0 -im; im 0] #Z = [ 1 0; 0 -1]  2Ã—2 Array{Complex{Float64},2}: 1.0+0.0im 0.0+0.0im 0.0+0.0im 0.707107+0.707107im  If you were able to follow me you are ready to understand quantum teleportation.\nQuantum teleportation Alice and Bob can share beforehand a special entangled two-qubit\n|0âŸ© ---[ H ]---â‹…--- | | (|00âŸ© + |11âŸ©)/âˆš2 | |0âŸ© -----------âŠ•---  ebit = CNOT*Hâ‚*ğŸğŸ # entangled bit -\u0026gt; shared  4-element Array{Float64,1}: 0.7071067811865475 0.0 0.0 0.7071067811865475  Alice takes the upper qubit and Bob the lower qubit. Then, they can separate.\nThat is the first stage of the protocol depicted below\n teleported state: |ÏˆâŸ© ------â‹…---[ H ]---[ z )=== | | | |0âŸ© ---[ H ]---â‹…----------------âŠ•-----------[ x )=== | |00âŸ© + |11âŸ© | ------------ | âˆš2 |0âŸ© -----------âŠ•------------------------------------[ XË£ ]---[ Zá¶» ]--- |ÏˆâŸ©  It is a very succint way of condensing an otherwise unexpeced phenomenom.\nGiven the moment, Alice will desire to deliver Bob some important piece of information encoded as a qubit.\n# The state Ïˆ Alice wants to teleport Î± = rand(Complex{Float64}) Î² = sqrt(1 - Î±*conj(Î±)) # |Î±|Â² + |Î²|Â² = 1 @assert Î±*conj(Î±) + Î²*conj(Î²) â‰ˆ 1 \u0026quot;State not properly normalized. Try with other (Î±,Î²)\u0026quot; Ïˆ = Î±*ğŸ + Î²*ğŸ # âˆˆ â„‚Â² â‰ â„‚ âŠ— â„‚ ; ÏÏˆ = Ïˆ*Ïˆ' âˆˆ â„‚ âŠ— â„‚ _Ïˆ = Ïˆ # we can do this only in a classic circuit (debugging purposes)  2-element Array{Complex{Float64},1}: 0.75190393025605 + 0.5381299416639849im 0.38086302728175303 + 0.0im  She applies a conditional-NOT to the entangled qubit based on the state to be teleported. Thus, both are entangled. Next, applies a Hadamard matrix to the state to be teleported.\ns = Ïˆ âŠ— ebit;  gate1 = CNOT âŠ— I(2) gate2 = H âŠ— I(4);  Ïˆ = gate2*gate1*s;  Alice measures first two bits, posibilities are 00, 01, 10, and 11\nPğŸğŸ = ğŸğŸ*ğŸğŸ' âŠ— I(2) # projections PğŸğŸ = ğŸğŸ*ğŸğŸ' âŠ— I(2) PğŸğŸ = ğŸğŸ*ğŸğŸ' âŠ— I(2) PğŸğŸ = ğŸğŸ*ğŸğŸ' âŠ— I(2);  ÏÏˆ = Ïˆ*Ïˆ' # density operator pğŸğŸ = tr(ÏÏˆ * PğŸğŸ) |\u0026gt; real # probabilities pğŸğŸ = tr(ÏÏˆ * PğŸğŸ) |\u0026gt; real pğŸğŸ = tr(ÏÏˆ * PğŸğŸ) |\u0026gt; real pğŸğŸ = tr(ÏÏˆ * PğŸğŸ) |\u0026gt; real;  @info \u0026quot; The probability of |ğŸğŸâŸ© is $pğŸğŸ\u0026quot; @info \u0026quot; The probability of |ğŸğŸâŸ© is $pğŸğŸ\u0026quot; @info \u0026quot; The probability of |ğŸğŸâŸ© is $pğŸğŸ\u0026quot; @info \u0026quot; The probability of |ğŸğŸâŸ© is $pğŸğŸ\u0026quot;  â”Œ Info: The probability of |ğŸğŸâŸ© is 0.2499999999999999 â”Œ Info: The probability of |ğŸğŸâŸ© is 0.2499999999999999 â”Œ Info: The probability of |ğŸğŸâŸ© is 0.2499999999999999 â”Œ Info: The probability of |ğŸğŸâŸ© is 0.2499999999999999  All outcomes have the same chance of appearing.\nicollapsed = argmax([pğŸğŸ, pğŸğŸ, pğŸğŸ, pğŸğŸ]) icollapsed = rand(1:4) # to avoid taking always the first Pcollapsed = [PğŸğŸ, PğŸğŸ, PğŸğŸ, PğŸğŸ][icollapsed];  x = (icollapsed == 2 || icollapsed == 4) |\u0026gt; Int z = (icollapsed == 3 || icollapsed == 4) |\u0026gt; Int @info \u0026quot; Alice measured x = $x and z = $z\u0026quot; @info \u0026quot; Alice qubits collapsed to $([\u0026quot;|ğŸğŸâŸ©\u0026quot;, \u0026quot;|ğŸğŸâŸ©\u0026quot;, \u0026quot;|ğŸğŸâŸ©\u0026quot;, \u0026quot;|ğŸğŸâŸ©\u0026quot;][icollapsed])\u0026quot;  â”Œ Info: Alice measured x = 1 and z = 0 â”Œ Info: Alice qubits collapsed to |ğŸğŸâŸ©  The resulting two classical bits are shared to Bob, who uses them to process his entangled bit.\nrange = 2icollapsed-1:2icollapsed Ïˆ = normalize!(Pcollapsed*Ïˆ)[range] # state after measurement of ğŸğŸ Ïˆ = Z^z * X^x * Ïˆ # Bob uses Alice classical bits x and z @assert _Ïˆ â‰ˆ Ïˆ \u0026quot;Teleported state has been corrupted\u0026quot; @info \u0026quot; Teleported |ÏˆâŸ© = ($(Ïˆ[1])) |ğŸâŸ© + ($(Ïˆ[2])) |ğŸâŸ© !!\u0026quot;  â”Œ Info: Teleported |ÏˆâŸ© = (0.75190393025605 + 0.5381299416639849im) |ğŸâŸ© + (0.3808630272817531 + 0.0im) |ğŸâŸ© !!  This is awesome! We have teleported a vast amount information just moving two bits. It is like seeing a sportsman pulling a truck with his beard!\nTeleportation technology While this may seem just a theoretical result, recent experiments suggest that an internet based on quantum technology could be feasible. A collaborative team of researchers teleported qubits (as photon states) over a 44 km fiber optic with a fidelity above 90%. The results have been published in PRX Quantum.\n","date":1609114424,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1609114424,"objectID":"64d7e5d15b48dcb8e8dc6b8783e39b69","permalink":"https://zyth0s.github.io/project/quantum-teleportation-tutorial/","publishdate":"2020-12-28T00:13:44.801Z","relpermalink":"/project/quantum-teleportation-tutorial/","section":"project","summary":"The tutorial is also hosted in GitHub.\nHave you ever heard of quantum teleportation and wondered what is it exactly? Until very recently I was like you. Even if I received academic formation (including quantum mechanics) I never got past pure astonishment.","tags":["Quantum Computing"],"title":"Quantum Teleportation Tutorial","type":"project"},{"authors":[],"categories":[],"content":"Energetic bonding analysis with ChemInt Daniel MenÃ©ndez Crespo\nMPI CPFS\n Outline  Features Basic usage Import DGrid surfaces Testing \u0026amp; Documentation Prototype embedding in DGrid Issues Draft paper.   Features  For molecular and periodic systems. Works with DGrid, Gamess, and PySCF wavefunction formats HF and DFT wavefunctions Parallel execution Exhaustive documentation Validity: ca. 39000 tests; 80% coverage Interactive Julia and C++ versions (both interface DGrid) \u0026hellip;   Load a wavefunction julia\u0026gt; using ChemInt julia\u0026gt; wfn = parse_wavefunction(\u0026quot;examples/Al_fcc.fhi\u0026quot;) [ Info: ğŸ“System: [ Info: Number of atoms 1 [ Info: Total charge 13.0 [ Info: Atom Coordinates (Bohr) [ Info: Nuclei 1 with Z = 13.0, position : [0.0, 0.0, 0.0] [ Info: ğŸ“Wavefunction: [ Info: Type: ChemInt.DGRIDWFN_Sol_Real [ Info: Input file examples/Al_fcc_1x1x1/Al_fcc.fhi [ Info: Checksum: 2dac66869215084036016f586bc8f45c389c39d54b71a0b1e5f094d76ade959d [ Info: DGrid v5.1.0 JLL wrapper compiled with AppleClang 11.0.3.11030032 (Darwin) [ Info: Number of molecular orbitals 9 [ Info: Number of occupied molecular orbitals 9 [ Info: Number of molecular primitives 18   Default configuration julia\u0026gt; surfopts = parse_config(wfn)[1] [ Info: Reproduce the input file used for the calculation: [ Info: -------------------------------------------------- ... [ Info: -------------------------------------------------- [ Info: ğŸ“Surface options: [ Info: Surfaces to be determined: [1] [ Info: ODE solver is BS3() [ Info: ODE reltol is 0.01 [ Info: ODE abstol is 0.0001 [ Info: Limits of search: [10.0] [ Info: â„– of rays is [5810]   String configuration iqaconfig = \u0026quot;\u0026quot;\u0026quot; [surface] [angular_quadrature] quality = \u0026quot;fine\u0026quot; # coarse | medium | fine | finest [radial_quadrature] quality = \u0026quot;coarse\u0026quot; # coarse | medium | fine | finest [beta_sphere] betasphere = true betafac_atom = [[1,2],[0.5,0.5]] ... \u0026quot;\u0026quot;\u0026quot;   Prepare IQA calculation name = joinpath(@__DIR__, \u0026quot;lih.wfn\u0026quot;) surfile = name * \u0026quot;.surf.h5\u0026quot; wfn = parse_wavefunction(name) display(wfn) surfopts, quadopts, xpolaropts, iqaopts, dftopts, locopts = parse_config(wfn, iqaconfig) ChemInt.adjust_beta_sphere!(quadopts, surfile, wfn) display(quadopts)   Quadrature options julia\u0026gt; quadopts [ Info: ğŸ“Quadrature options: [ Info: Number of angular points inside [434, 434] [ Info: Number of radial points outside [200, 200] [ Info: Number of radial points inside [200, 200] [ Info: Radial outside quadrature Gauss-Legendre [ Info: Radial inside quadrature Gauss-Legendre [ Info: Radial outside mapping 2 [ Info: Radial inside mapping 3 [ Info: Slater-Bragg radii [0.0, 0.0] [ Info: Î²-sphere factor [0.6, 0.6] [ Info: Î²-sphere radii [0.0, 0.0] [ Info: Rmin of surfaces [0.0, 0.0]   Multi-/bi-polar options julia\u0026gt; xpolaropts [ Info: ğŸ“Bi-/multi-polar expansion options: [ Info: Maximum l orders outside Î²-sphere: [6, 6] [ Info: Maximum l orders inside Î²-sphere: [4, 4]   IQA integration options julia\u0026gt; iqaopts [ Info: ğŸ“IQA integration options: [ Info: â„– basins to ingegrate: 2 [ Info: â„– pairs to ingegrate: 1 [ Info: Basins to ingegrate: [1, 2] [ Info: Pairs to ingegrate: [[1, 2]] [ Info: Convergence threshold for bipolar = 1.0e-8 [ Info: Romberg extrapolation? false [ Info: Monadic diagonalization? false [ Info: Integrate exchange \u0026amp; correlation? true [ Info: Orbitals in energy window [-Inf, Inf] [ Info: Recovery? false   DFT options julia\u0026gt; dftopts [ Info: ğŸ“DFT options: [ Info: Activated? true [ Info: Kinetic functional: [ Info: Exchange or exchange-correlation functional: gga_x_pbe [ Info: Correlation functional: gga_c_pbe [ Info: Fraction of HF exchange is = 0.0   Find basin boundaries julia\u0026gt; find_surfaces(surfopts, wfn) [ Info: Surfaces to be determined: [1] [ Info: Basin 1: [ Info: Trust sphere radius = 2.2000000000000006 [ Info: Suggested Î²-sphere radius = 1.4000000000000001 [ Info: Basin 1: Surface of basin 1: 100%[================] Time: 0:01:03 [ Info: Closest surface point mináµ£(||r - Rnuc||) = 2.40 [ Info: Farthest surface point maxáµ£(||r - Rnuc||) = 10.0 ...  Writes to *.surf.h5 file.\n Run IQA Integrate IQA energy components, LIs, and DIs.\njulia\u0026gt; iqa = iqa_decomposition(surfile, wfn, quadopts, xpolaropts, iqaopts, dftopts)  Writes to *.iqa.#.json and *.iqa.json files.\n IQA summary: Monocentric julia\u0026gt; iqa.monos[1] ğŸ“Intra components of basin: 1 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ kinetic energy = +7.36046127 self nuc-el energy = -16.39957368 energy elec( 1)-nuc( 2) = -0.69443763 Coulomb energy = +3.46606343 xc energy = -1.66088134 x energy = -1.66088134 c energy = +0.00000000 xc (DFT) energy = +0.00000000 x (DFT) energy = +0.00000000 c (DFT) energy = +0.00000000 Total ee repusion energy = +1.80518210 Localization index (xc) = +1.99249773 Localization index (x ) = +1.99249773 Localization index ( c) = +0.00000000 Self-energy = -7.23393032 Laplacian = +0.00000000 NÂº electrons = +2.09697706 Basin charge = +0.90302294   IQA summary: Interactions julia\u0026gt; iqa.pairs[1] ğŸ“Bicentric analysis of pair 1 2 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ exact multipolar diff â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Distance (aâ‚€) +3.02173254 Total interaction -0.28058656 +0.64689317 -0.92747973 NN total repulsion +0.99280792 energy elec( 1)-nuc( 2) -1.80846292 -0.32421556 -1.48424736 energy elec( 2)-nuc( 1) -0.69443763 -0.15707837 -0.53735927 EE total repulsion +1.22950607 +0.13537917 +1.09412690 EE Coulomb energy +1.26367450 +0.13537917 +1.12829533 EE xc energy -0.03416843 +0.00000000 -0.03416843 EE x energy -0.03416843 +0.00000000 -0.03416843 EE c energy +0.00000000 +0.00000000 +0.00000000 Clasical interaction (xc out) -0.24641813 +0.64689317 -0.89331130 Delocalization index (xc) +0.20799039 Delocalization index (x ) +0.20799039 Delocalization index ( c) +0.00000000   IQA summary: Total julia\u0026gt; iqa ğŸ“Total energy components âŸ¨Î¨|â‹…|Î¨âŸ© â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ TOTAL ENERGY = -7.97528439 ğ“” = ğ“£ + ğ“¥ KINETIC = +7.97864654 ğ“£ POTENTIAL = -15.95393093 ğ“¥ = ğ“¥nn + ğ“¥ne + ğ“¥ee NUC-NUC = +0.99280792 ğ“¥nn NUC-EL = -20.43317153 ğ“¥ne EL-EL = +3.48643268 ğ“¥ee = ğ“¥H + ğ“¥xc EL-EL Coulomb = +5.62802512 ğ“¥H EL-EL (Exc+Corr) = -2.14159244 ğ“¥xc = ğ“¥x + ğ“¥c EL-EL Exc = -2.14159244 ğ“¥x EL-EL Corr = +0.00000000 ğ“¥c 2ğ“£ + ğ“¥ = +0.00336216 VIRIAL RATIO = -1.99957861 ğ“¥/ğ“£ ENET = -7.69469783 âˆ‘A ğ“”á´¬ EINT = -0.28058656 âˆ‘A,B ğ“¥á´¬á´® EINT class = -0.24641813 âˆ‘A,B ğ“¥nná´¬á´® + ğ“¥neá´¬á´® + ğ“¥neá´®á´¬ + ğ“¥Há´¬á´® EINT exc+corr = -0.03416843 âˆ‘A,B ğ“¥xcá´¬á´® TOTAL CHARGE = +0.00865004 Qá´¬ = âˆ‘A (Zá´¬ - Ná´¬) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€   Load stored results julia\u0026gt; iqa = ChemInt.load_iqajson(\u0026quot;examples/lih/lih.gwf.json\u0026quot;) ğŸ“Intra components of basin: 1 ... ğŸ“Bicentric analysis of pair 1 2 ... ğŸ“Total energy components âŸ¨Î¨|â‹…|Î¨âŸ© ... julia\u0026gt; iqa.CHARGE 0.00041845455180711255   Analyze results For example, check convergence of ğ“¥H.\njulia\u0026gt; ChemInt.print_convergence(iqa.monos[1], 6) [ Info: ğŸ“ LM Convergence [Total]: [ Info: L COULOMB XC X CORR [ Info: --- --------------- --------------- --------------- --------------- [ Info: 0 +3.465834 -1.659177 -1.659177 +0.000000 [ Info: 1 +3.465981 -1.661697 -1.661697 +0.000000 [ Info: 2 +3.466030 -1.661735 -1.661735 +0.000000 [ Info: 3 +3.466048 -1.661744 -1.661744 +0.000000 [ Info: 4 +3.466053 -1.661747 -1.661747 +0.000000 [ Info: 5 +3.466055 -1.661748 -1.661748 +0.000000 [ Info: 6 +3.466055 -1.661748 -1.661748 +0.000000   Import DGrid surfaces Example in examples/LiMgN/convert_basins.jl.\n# 1. Import basins to ChemInt format import_dgrid_surface(bsn_name, npang, wfn) ... # 2. Reorder basins if necessary reorder_surfaces(surfile, mapping) # 3. Generate point cloud wfn = parse_wavefunction(wfnfile) for ibasin in 1:wfn.natm raycuts2pointcloud(wfn.coords, surfile; ibasin, format= :csv) end # Visualize with Avizo     Validation julia\u0026gt; ] (ChemInt) pkg\u0026gt; test Testing ChemInt ... Test Summary: | Pass Broken Total ChemInt.jl: unit tests | 38928 5 38933 ChemInt.jl: integrated tests | 1158 1158 ChemInt.jl: full examples | 120 120 Testing ChemInt tests passed   Unit tests ChemInt.jl: unit tests | 38992 1 5 38998 Parsing of AIM WFN format | 22 22 Parsing of DGrid Gamess AIM format: LiH | 16 16 Parsing of DGrid FHI-aims format: Al Î“-point | 15 15 WFN traits | 31 5 36 âˆ‡Ï(ğ«): Fortran â‰¡ Promolden | 5 5 âˆ‡Ï(ğ«): Julia â‰¡ Promolden | 5 5 âˆ‡Ï(ğ«): Julia â‰¡ Fortran | 101 101 âˆ‡Ï(ğ«): DGrid routines â‰¡ bpy | 4 4 âˆ‡Ï(ğ«): Wrapper â‰¡ DGrid | 6 6 Ï(ğ«): ChemInt â‰¡ Promolden | 7 7 Ï(ğ«): DGridJLL â‰¡ Promolden | 7 7 Ï(ğ’“): DGridJLL â‰¡ DGrid | 2 2 Ï(ğ«): Equivalence of routines | 402 402 Ï„(ğ«): ChemInt â‰¡ Promolden | 7 7 Ï„(ğ«): DGridJLL â‰¡ Promolden | 7 7 Ï„(ğ«): Equivalence of routines | 402 402 Ïƒ(ğ«): ChemInt â‰¡ Promolden | 5 5 Ïƒ(ğ«): DGridJLL â‰¡ Promolden | 5 5 Ïƒ(ğ«): Equivalence of routines | 202 202 Î”Ï(ğ«): ChemInt â‰¡ Promolden | 3 3 Î”Ï(ğ«): DGridJLL â‰¡ Promolden | 3 3 ğ—›Ï(ğ«): vs Promolden | 3 3 Ïáµ¢â±¼(ğ«): ChemInt â‰¡ Promolden | No tests Ïáµ¢â±¼(ğ«): Equivalence of routines | 201 201 Defaults: surface | 26 26 Defaults: quadrature | 60 60 Defaults: x-polar | 23 23 Defaults: IQA integration | 37 37 Defaults: DFT | 13 13 Defaults: Localization | 5 5 TOML parsing: surface | 4 4 TOML parsing: quadrature | 3 3 TOML parsing: x-polar | 1 1 TOML parsing: IQA integration | 4 4 TOML parsing: DFT | No tests TOML parsing: Localization | No tests Sphere quadrature: Lebedev-Laikov | 96 96 Radial quadrature: Euler-McLaurin | 9 9 Radial quadrature: Gauss-Legendre | 48 48 Radial quadrature: Clenshaw-Curtis | 700 700 Radial quadrature: Gauss-Chebyshev 1st order | 19 19 Radial quadrature: Gauss-Chebyshev 2nd order | 9 9 Radial quadrature: Trapezoidal | 9 9 n! | 16 16 n!! | 171 171 Real Spherical Harmonics | 6 6 cáµ | 49 49 dáµ | 33938 33938 ğ‘» | 2 2 IQA_Mono_OutÎ² data | 35 35 IQA_Mono_InÎ² data | 33 33 IQA_Mono data | 36 36 Mono += Region | 6 6 IQA_Pair data | 40 40 IQA data | 25 25 Î”m | 1 1 ğ“¥áµƒ | No tests ğ“¥mat | 2088 2088     File organization  ChemInt: main file. data_wfn: hold WFN parameters. data_iqa: hold IQA energies. opts_*: hold calculation options. iqa_decomposition: IQA integration driver find_surfaces: surface search driver eval_*: evaluation of point properties monocentric_*: monocentric integrals bicentric_*: bicentric integrals   Further details  See the documentation at docs/build/html/index.html. Build with makedocs.sh.   Embedding Example calling ChemInt from C in embedded.\nPass the configuration string and a logging filename to ChemInt, which logs the progress and generates the *.json files with the outputs. Those files can be read with load_iqajson().\n Issues  Integration accuracy. Example: Charge error in LiMgN conventional cell is 0.15 e.  Changing integration parameters does not reduce error. Surface perturbation alters the error. Even if surface is imported from DGrid. Integration routines were carefully tested. Refined surface but it was worse.    Basin integration: Close to DGrid.\nCell integration: Errors add up. Is it tolerable?\n Draft Comments, suggestions?\n","date":1578009600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1578009600,"objectID":"0e6de1a61aa83269ff13324f3167c1a9","permalink":"https://zyth0s.github.io/slides/example/","publishdate":"2020-01-03T00:00:00Z","relpermalink":"/slides/example/","section":"slides","summary":"Energetic bonding analysis with ChemInt Daniel MenÃ©ndez Crespo\nMPI CPFS\n Outline  Features Basic usage Import DGrid surfaces Testing \u0026amp; Documentation Prototype embedding in DGrid Issues Draft paper.   Features  For molecular and periodic systems.","tags":[],"title":"Energetic bonding analysis with ChemInt","type":"slides"},{"authors":[],"categories":[],"content":"Outline  LiMgN  Calculated surface  Volume; Charge   Imported surface  Volume; Laplacian; Charge     BeAlB  Calculated surface  Volume; Charge     LiAlSi  Calculated surface  Volume; Charge       1. LiMgN: Calculated surface That is, surface computed with an internal algorithm.\n LiMgN Volume (bohr^3)     Li Mg N Cell     ChemInt CalcSurf 20.95 42.86 151.42 861.32   DGrid 20.74 38.57 151.96 845.08   $\\Delta V$ 0.21 4.29 0.54 16.24    Li has spikes and Mg has a crest.\nError concentrated in Mg basins.\n Li basin  Mg basin  LiMgN Charge (e)     Li Mg N Cell     ChemInt CalcSurf 0.82 1.56 -2.42 -0.15   DGrid 0.83 1.60 -2.43 +0.00   $\\Delta V$ 0.01 0.04 +0.01 -0.15    Error concentrated in Mg basins.\n 2. LiMgN: Imported DGrid surface  LiMgN Volume (bohr^3)     Li Mg N Cell     ChemInt ImportSurf 21.19 40.01 153.32 857.96   DGrid 20.74 38.57 151.96 845.08   $\\Delta V$ 0.45 1.44 2.50 12.88    $\\sigma(V^{Li}) = 0.5$; $\\sigma(V^{Mg}) = 0.6$; $\\sigma(V^{N}) = 0.3$.\nNo spikes or crests.\n Li basin imported  Mg basin imported  N basin imported  LiMgN Laplacian (a.u.)     Li Mg N     ChemInt ImportSurf 0.034 0.015 0.015    $\\sigma(\\Delta\\rho^{Li}) = 0.024$; $\\sigma(\\Delta\\rho^{Mg}) = 0.042$; $\\sigma(\\Delta\\rho^{N}) = 0.003$.\n LiMgN Charge (e)     Li Mg N Cell     ChemInt ImportSurf 0.81 1.57 -2.43 -0.17   DGrid 0.83 1.60 -2.43 +0.00   $\\Delta V$ 0.02 0.03 +0.00 -0.17    $\\sigma(Q^{Li}) = 0.00$; $\\sigma(Q^{Mg}) = 0.01$; $\\sigma(Q^{N}) = 0.00$.\n 1. BeAlB: Calculated surface With an internal algorithm.\n BeAlB Volume (bohr^3)     Be Al B Cell     ChemInt ImportSurf 18.31 35.02 155.45 835.11   DGrid 17.16 33.28 155.68 824.48   $\\Delta V$ 1.25 1.74 0.23 11.37     Be basin  Al basin  B basin  BeAlB Charge (e)     Be Al B Cell     ChemInt ImportSurf 1.47 2.14 -3.66 -0.20   DGrid 1.50 2.17 -3.67 +0.00   $\\Delta V$ 0.03 0.03 -0.01 -0.20     1. LiAlSi: Calculated surface With an internal algorithm.\n LiAlSi Volume (bohr^3)     Li Al Si Cell     ChemInt ImportSurf 24.95 76.83 253.10 1423.49   DGrid 24.50 74.23 254.31 1412.16   $\\Delta V$ 0.45 2.60 1.21 11.33     LiAlSi Charge (e)     Li Al Si Cell     ChemInt ImportSurf 0.83 1.56 -2.41 -0.08   DGrid 0.83 1.58 -2.41 +0.00   $\\Delta V$ 0.00 0.02 +0.00 -0.08     ","date":1578009600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1578009600,"objectID":"12884a179a0c6d8bf952c1c9b8f2cdde","permalink":"https://zyth0s.github.io/slides/integ_accuracy/","publishdate":"2020-01-03T00:00:00Z","relpermalink":"/slides/integ_accuracy/","section":"slides","summary":"Outline  LiMgN  Calculated surface  Volume; Charge   Imported surface  Volume; Laplacian; Charge     BeAlB  Calculated surface  Volume; Charge     LiAlSi  Calculated surface  Volume; Charge       1.","tags":[],"title":"Integration accuracy with ChemInt","type":"slides"},{"authors":["Daniel MenÃ©ndezâ€Crespo","Aurora Costales","Evelio Francisco","Ãngel MartÃ­nâ€…PendÃ¡s"],"categories":null,"content":"","date":1523728543,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1523728543,"objectID":"6aa6d9c2214866fd9c3e98f0fe515985","permalink":"https://zyth0s.github.io/publication/realspace-in-situ-bond-energies-toward-a-consistent-energetic-definition-of-bond-strength/","publishdate":"2018-04-14T17:55:43.44Z","relpermalink":"/publication/realspace-in-situ-bond-energies-toward-a-consistent-energetic-definition-of-bond-strength/","section":"publication","summary":"A rigorous definition of intrinsic bond strength based on the partitioning of a molecule into realâ€space fragments is presented. Using the domains provided by the quantum theory of atomsâ€inâ€molecules (QTAIM) together with the interacting quantum atoms (IQA) energetic decomposition, we show how an in situ bond strength, matching all the requirements of an intrinsic bond energy, can be defined between each pair of fragments. Total atomization or fragmentation energies are shown to be equal to the sum of these in situ bond energies (ISBEs) if the energies of the fragments are measured with respect to their inâ€theâ€molecule state. These energies usually lie above the ground state of the isolated fragments by quantities identified with the standard fragment relaxation or deformation energies, which are also provided by the protocol. Deformation energies bridge dissociation energies with ISBEs, and can be dissected by using wellâ€known tools of realâ€space theories of chemical bonding. Similarly, ISBEs can be partitioned into ionic and covalent contributions, and this feature adds to the chemical appeal of the procedure. All the energetic quantities examined are observable and amenable, in principle, to experimental determination. Several systems, exemplifying the role of each energetic term presented herein, are used to show the power of the approach.","tags":null,"title":"Realâ€Space In Situ Bond Energies: Toward A Consistent Energetic Definition of Bond Strength","type":"publication"},{"authors":["Evelio Francisco","Daniel MenÃ©ndez Crespo","Aurora Costales","Ãngel MartÃ­n PendÃ¡s"],"categories":null,"content":"","date":1487273595,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1487273595,"objectID":"be4abfd61f449f032307c637ade55ad4","permalink":"https://zyth0s.github.io/publication/a-multipolar-approach-to-the-interatomic-covalent-interaction-energy/","publishdate":"2017-02-16T19:33:15.405Z","relpermalink":"/publication/a-multipolar-approach-to-the-interatomic-covalent-interaction-energy/","section":"publication","summary":"Interatomic exchangeâ€correlation energies correspond to the covalent energetic contributions to an interatomic interaction in real space theories of the chemical bond, but their widespread use is severely limited due to their computationally intensive character. In the same way as the multipolar (mp) expansion is customary used in biomolecular modeling to approximate the classical Coulomb interaction between two charge densities \\rho_A(r) and \\rho_B(r), we examine in this work the mp approach to approximate the interatomic exchangeâ€correlation (xc) energies of the Interacting Quantum Atoms method. We show that the full xc mp series is quickly divergent for directly bonded atoms (1â€“2 pairs) albeit it works reasonably well most times for 1â€“ n (nâ€‰â€‰2) interactions. As with conventional perturbation theory, we show numerically that the xc series is asymptotically convergent and that, a truncated xc mp approximation retaining terms up to l_1+l2=2 usually gives relatively accurate results, sometimes even for directly bonded atoms. Our findings are supported by extensive numerical analyses on a variety of systems that range from several standard hydrogen bonded dimers to typically covalent or aromatic molecules. The exact algebraic relationship between the monopoleâ€monopole xc mp term and the interâ€atomic bond order, as measured by the delocalization index of the quantum theory of atoms in molecules, is also established.","tags":null,"title":"A multipolar approach to the interatomic covalent interaction energy","type":"publication"},{"authors":["Ãngel MartÃ­n PendÃ¡s","JosÃ© Manuel Guevara-Vela","Daniel MenÃ©ndez Crespo","Aurora Costales","Evelio Francisco"],"categories":null,"content":"","date":1481571606,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1481571606,"objectID":"feb32611a1f7b7ab68c4f64da83ef0b5","permalink":"https://zyth0s.github.io/publication/an-unexpected-bridge-between-chemical-bonding-indicators-and-electrical-conductivity-through-the-localization-tensor/","publishdate":"2016-12-12T19:40:06.375Z","relpermalink":"/publication/an-unexpected-bridge-between-chemical-bonding-indicators-and-electrical-conductivity-through-the-localization-tensor/","section":"publication","summary":"While the modern theory of the insulating state shows that the conducting or insulating properties of a system can be extracted solely from the ground state properties via the so-called localization tensor (LT), no chemical reading of this important quantity has ever been offered. Here, a remarkable link between the LT and the bond orders as described by the delocalization indices (DIs) of chemical bonding theory is reported. This is achieved through a real space partition of the LT into intra- and interatomic contributions. We show that the convergence or divergence of the LT in the thermodynamic limit, which signals the insulating or conducting nature of an extended system, respectively, can be nailed down to DIs. This allows for the exploitation of traditional chemical intuition to identify essential and spectator atomic groups in determining electrical conductivity. The thermodynamic limit of the LT is controlled by the spatial decay rate of the interatomic DIs, exponential in insulators and power-law in conductors. Computational data of a few selected toy systems corroborate our results.","tags":null,"title":"An unexpected bridge between chemical bonding indicators and electrical conductivity through the localization tensor","type":"publication"}]