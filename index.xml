<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Daniel Men√©ndez Crespo</title>
    <link>https://zyth0s.github.io/</link>
      <atom:link href="https://zyth0s.github.io/index.xml" rel="self" type="application/rss+xml" />
    <description>Daniel Men√©ndez Crespo</description>
    <generator>Wowchemy (https://wowchemy.com)</generator><language>en-us</language><lastBuildDate>Fri, 01 Oct 2021 19:43:30 +0000</lastBuildDate>
    <image>
      <url>https://zyth0s.github.io/images/icon_hu0b7a4cb9992c9ac0e91bd28ffd38dd00_9727_512x512_fill_lanczos_center_3.png</url>
      <title>Daniel Men√©ndez Crespo</title>
      <link>https://zyth0s.github.io/</link>
    </image>
    
    <item>
      <title>Interacting Quantum Atoms Method for Crystalline Solids</title>
      <link>https://zyth0s.github.io/publication/iqa-solids/</link>
      <pubDate>Fri, 01 Oct 2021 19:43:30 +0000</pubDate>
      <guid>https://zyth0s.github.io/publication/iqa-solids/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Scientific Memes</title>
      <link>https://zyth0s.github.io/post/scientific-memes/</link>
      <pubDate>Mon, 04 Jan 2021 16:37:15 +0100</pubDate>
      <guid>https://zyth0s.github.io/post/scientific-memes/</guid>
      <description>&lt;p&gt;Science is an indisputable source of progress for our society. A topical
example is the use of recent advances in biochemistry to foster new vaccines
for Sars-CoV-19.&lt;/p&gt;
&lt;p&gt;The compendium of acquired scientific knowledge is so vast that nobody is
expected to be illustrated in every branch of science, not even a field or
subfield. For that reason it is difficult to even be aware of the main
questions, concepts or definitions addressed currently by almost any
discipline. In this regard, it would be helpful if we had at our disposal a
collection of brief descriptions for them.&lt;/p&gt;
&lt;p&gt;Here we seek to condense in the least amount of words, images, or recording
length a given concept in science.  Much like memes in Dawkins&#39; description of
the term (and contrary to popular usage) scientific memes are meant to be
&lt;em&gt;units of scientific information, such as a scientific concept or question,
that are transmitted verbally or visually from one mind to another&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Now you might ask how should those memes be. Something like a dictionary entry?
Quite not. We would like a more rich medium, with some illustration to it.  A
very good example is the following &lt;a href=&#34;https://www.i-programmer.info/programming/theory/3758-understanding-the-fourier-transform.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;explanation of Fourier transform by Stuart
Riffle&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;fourier_transform.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;The same format has been used to explain other mathematical concepts (examples
taken from &lt;a href=&#34;https://betterexplained.com/articles/colorized-math-equations/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Better
explained&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;euler_number.png&#34; alt=&#34;&#34;&gt;
&lt;img src=&#34;euler_formula.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;A not less impressive format is used by physics professor &lt;a href=&#34;https://bunim180.wixsite.com/jurij0001&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Yuri
Kovalenok&lt;/a&gt;. The following is only an
example of a large collection of notebook notes handwritten by Yuri&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;rocket.webp&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;More like that by twitter user &lt;a href=&#34;&#34;&gt;@ThuyNganVu&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;quadratic.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;Those notes are based on videos recorded by Youtube user
&lt;a href=&#34;http://youtube.com/c/3blue1brown&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;3blue1brown&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;I am pretty sure there are more examples like those around but those are the
ones I encountered. Often when I learn a new concept I try to leave a note for myself that
helps me when I forget what is the meaning.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Umklapp process: part of the momentum that the neutron gives to the solid
goes to the centre of mass of the solid. The other part transforms into
phonon modes.&lt;/li&gt;
&lt;li&gt;Anderson &amp;amp; Kondo? Is the hybridisation of strongly correlated electron states
with free electron bands. The problem is how to hybridise states of
completely different nature.&lt;/li&gt;
&lt;li&gt;Pierls instability is like the resonance in poly-acetylene between
alternating bonds. The system spontaneously dimerises in two resonant ground
state configurations.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Bloch states are closely related to chemists resonant structure concept&lt;/em&gt;
‚ÄúModern Cond matter physics book‚Äù&lt;/li&gt;
&lt;li&gt;Spin-orbit coupling: &lt;em&gt;Physically it can be understood as the Zeeman coupling
between the magnetic moment carried by electron spin and the effective
magnetic field seen by the electron in the reference frame in which it is at
rest, while the other charges move around it&lt;/em&gt; ‚ÄúModern Condensed matter Physics
book‚Äù&lt;/li&gt;
&lt;li&gt;Oxidation state: is the formal charge minus electrons shared with less
electronegative atoms.&lt;/li&gt;
&lt;li&gt;Josephson junction ‚Äì &lt;em&gt;a non-superconducting region through which the Cooper
pairs responsible for superconductivity can tunnel. This semiconducting ‚Äúweak
link‚Äù provides a persistent phase difference between the superconductors in the
circuit, similar to the way that a classical battery provides a persistent
voltage drop in an electronic circuit. Thanks to this phase difference, a
superconducting current (that is, a current with zero dissipation) flows when
the junction is embedded in the superconducting circuit&lt;/em&gt; Featured in Physics
World&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Here‚Äôs an extremely brief version of the black hole information paradox:
Stuff falls into a black hole. Over time ‚Äî a long, long time ‚Äî the black hole
‚Äúevaporates.‚Äù What happened to the stuff? According to the rules of gravity,
it‚Äôs gone, its information lost forever. But according to the rules of quantum
mechanics, information can never be lost. Therefore, paradox.&lt;/em&gt;¬†Featured in
Quanta magazine&lt;/li&gt;
&lt;li&gt;&lt;em&gt;The¬†biggest puzzle in cosmology right now¬†has to do with the Hubble
constant, a measure of the speed at which the universe is expanding. Data
from the early universe predicts one value. Data from the modern universe
predicts another.&lt;/em&gt; Featured in Quanta magazine&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://t.co/M7OW1BYT1R?amp=1&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Hawking radiation by Gaston Giribet&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Variational Quantum Eigensolver for Ising Hamiltonians</title>
      <link>https://zyth0s.github.io/project/variational-quantum-eigensolver-for-ising-hamiltonians/</link>
      <pubDate>Tue, 29 Dec 2020 09:54:08 +0000</pubDate>
      <guid>https://zyth0s.github.io/project/variational-quantum-eigensolver-for-ising-hamiltonians/</guid>
      <description>&lt;p&gt;Jupyter notebook &lt;a href=&#34;https://github.com/zyth0s/SciAlgs.jl/blob/master/src/QM/tutorial_quantum_computing_2.ipynb&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Variational Quantum Eigensolver (VQE) algorithm is a quantum realization of Ritz&amp;rsquo;s variational method.&lt;/p&gt;
&lt;p&gt;A more lengthy explanation is given by &lt;a href=&#34;https://www.mustythoughts.com/variational-quantum-eigensolver-explained&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Micha≈Ç Stƒôch≈Çy&lt;/a&gt;.
Here I will just work out how it operates.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Ising hamiltonians are the easiest to map to quantum circuits and learning how to encode
them will help us with more complicated hamiltonians.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;using LinearAlgebra: I, tr
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;# Computational basis
ùüé = [1,0]
ùüè = [0,1]
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;X = [0 1; 1 0]
Z = [1 0; 0 -1] # we measure in Z basis
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;H = [1 1; 1 -1]/‚àö2
p = H * ùüé # = |+‚ü©
m = H * ùüè # = |-‚ü©
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;rotate-qubits-to-measure-other-pauli-matrices-than-sigma_x&#34;&gt;Rotate qubits to measure other Pauli matrices (than $\sigma_x$)&lt;/h2&gt;
&lt;p&gt;As an example, if we measure in the Z basis its not possible to distinguish between $|+\rangle$ and
$|-\rangle$.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;@info &amp;quot;‚ü®+|Z|+‚ü© ‚âà ‚ü®-|Z|-‚ü©&amp;quot;, p&#39;*Z*p ‚âà m&#39;* Z*m
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;‚îå Info: (&amp;quot;‚ü®+|Z|+‚ü© ‚âà ‚ü®-|Z|-‚ü©&amp;quot;, true)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Rotating the basis in a certain way allows us to unequivocally distinguish them.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;Ry(Œ∏) = [cos(Œ∏/2) -sin(Œ∏/2); sin(Œ∏/2) cos(Œ∏/2)]
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;@assert Ry(œÄ/2)*p ‚âà ùüè
@assert Ry(œÄ/2)*m ‚âà ùüé
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;p_rot = Ry(-œÄ/2)*p
m_rot = Ry(-œÄ/2)*m
@info &amp;quot;‚ü®+|Z|Ry(-œÄ/2)|+‚ü© ‚âà ‚ü®-|Z|Ry(-œÄ/2)|-‚ü©&amp;quot;, p_rot&#39;*Z*p_rot ‚âà m_rot&#39;* Z*m_rot
@info &amp;quot;Outcome of ‚ü®+|Z|Ry(-œÄ/2)|+‚ü© = &amp;quot;, p_rot&#39;*Z*p_rot
@info &amp;quot;Outcome of ‚ü®-|Z|Ry(-œÄ/2)|-‚ü© = &amp;quot;, m_rot&#39;* Z*m_rot
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;‚îå Info: (&amp;quot;‚ü®+|Z|Ry(-œÄ/2)|+‚ü© ‚âà ‚ü®-|Z|Ry(-œÄ/2)|-‚ü©&amp;quot;, false)
‚îå Info: (&amp;quot;Outcome of ‚ü®+|Z|Ry(-œÄ/2)|+‚ü© = &amp;quot;, 0.9999999999999998)
‚îå Info: (&amp;quot;Outcome of ‚ü®-|Z|Ry(-œÄ/2)|-‚ü© = &amp;quot;, -0.9999999999999998)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The solution is to apply&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$R_y(‚àí\pi/2)$      if Hamiltonian has $\hat{X}$&lt;/li&gt;
&lt;li&gt;$R_x(\pi/2)$       if Hamiltonian has $\hat{Y}$&lt;/li&gt;
&lt;li&gt;$I$                if Hamiltonian has $\hat{Z}$&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;before measurement. Consequently, the circuit will be different for each Pauli
matrix.&lt;/p&gt;
&lt;h2 id=&#34;divide-the-hamiltonian-into-single-pauli-terms&#34;&gt;Divide the Hamiltonian into single Pauli terms&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;ùìó‚ÇÅ = 2Z
ùìó‚ÇÇ = X
ùìó‚ÇÉ = I(2)
ùìó = ùìó‚ÇÅ + ùìó‚ÇÇ + ùìó‚ÇÉ
@assert ùìó ‚âà [3 1; 1 -1]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;initial-state&#34;&gt;Initial state&lt;/h2&gt;
&lt;p&gt;We use a parametrized initial wavefunction for reasons that will be explained
later but you can already guess that we will do a variational search.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;# Ansatz will be Ry(Œ∏)*ùüé
ansatz(Œ∏) = Ry(Œ∏)*ùüé
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;a-circuit-for-each-term&#34;&gt;A circuit for each term&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;function vqe(Œ∏, verbose=false)

   verbose &amp;amp;&amp;amp; @info &amp;quot;Œ∏ = $(Œ∏[1])&amp;quot;
   # Circuit for ùìó‚ÇÅ: œà ---[ h‚ÇÅ )===

   œà = ansatz(Œ∏[1])

   h‚ÇÅ = 2œà&#39; * Z * œà
   verbose &amp;amp;&amp;amp; @info &amp;quot;  E‚ÇÅ = $h‚ÇÅ&amp;quot;

   # Circuit for ùìó‚ÇÇ: œà ---[ Ry ]---[ h‚ÇÇ )===

   œà = Ry(-œÄ/2)*ansatz(Œ∏[1])

   h‚ÇÇ = œà&#39; * Z * œà
   verbose &amp;amp;&amp;amp; @info &amp;quot;  E‚ÇÇ = $h‚ÇÇ&amp;quot;

   # Circuit for ùìó‚ÇÉ:

   h‚ÇÉ = 1
   verbose &amp;amp;&amp;amp; @info &amp;quot;  E‚ÇÉ = $h‚ÇÉ&amp;quot;

   verbose &amp;amp;&amp;amp; @info &amp;quot;  ‚ü®œà($Œ∏[1])|ùìó|œà($Œ∏[1])‚ü© = $(h‚ÇÅ + h‚ÇÇ + h‚ÇÉ)&amp;quot;
   h‚ÇÅ + h‚ÇÇ + h‚ÇÉ
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;For two single parameter values we have&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;vqe([0],true)
vqe([œÄ],true)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;‚îå Info: Œ∏ = 0
‚îå Info:   E‚ÇÅ = 2.0
‚îå Info:   E‚ÇÇ = 2.220446049250313e-16
‚îå Info:   E‚ÇÉ = 1
‚îå Info:   ‚ü®œà([0][1])|ùìó|œà([0][1])‚ü© = 3.0
‚îå Info: Œ∏ = œÄ
‚îå Info:   E‚ÇÅ = -2.0
‚îå Info:   E‚ÇÇ = -2.220446049250313e-16
‚îå Info:   E‚ÇÉ = 1
‚îå Info:   ‚ü®œà([œÄ][1])|ùìó|œà([œÄ][1])‚ü© = -1.0
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;using Optim
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;result = optimize(vqe, [0.0], BFGS())
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt; * Status: success

 * Candidate solution
    Final objective value:     -1.236068e+00

 * Found with
    Algorithm:     BFGS

 * Convergence measures
    |x - x&#39;|               = 6.65e-06 ‚â∞ 0.0e+00
    |x - x&#39;|/|x&#39;|          = 2.48e-06 ‚â∞ 0.0e+00
    |f(x) - f(x&#39;)|         = 4.94e-11 ‚â∞ 0.0e+00
    |f(x) - f(x&#39;)|/|f(x&#39;)| = 4.00e-11 ‚â∞ 0.0e+00
    |g(x)|                 = 1.37e-11 ‚â§ 1.0e-08

 * Work counters
    Seconds run:   0  (vs limit Inf)
    Iterations:    4
    f(x) calls:    10
    ‚àáf(x) calls:   10
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;Œ∏_opt = Optim.minimizer(result)[1]
energy_opt = Optim.minimum(result)
@info &amp;quot;VQE: Œ∏* = $Œ∏_opt, E* = $energy_opt&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;‚îå Info: VQE: Œ∏* = -2.6779450445907376, E* = -1.2360679774997898
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;more-advanced-hamiltonians&#34;&gt;More advanced hamiltonians&lt;/h2&gt;
&lt;p&gt;Fermionic operators can be transformed into Ising-type hamiltonians in several ways.
The most common are the Jordan-Wigner and Bravyi-Kitaev transformations.&lt;/p&gt;
&lt;p&gt;In this example we only had a single qubit but it can be extended
to multiple qubits.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Psi4julia</title>
      <link>https://zyth0s.github.io/project/psi4julia/</link>
      <pubDate>Mon, 28 Dec 2020 12:39:29 +0000</pubDate>
      <guid>https://zyth0s.github.io/project/psi4julia/</guid>
      <description>&lt;p&gt;This is an attempt to reproduce Psi4NumPy with Julia.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Tight binding tutorial</title>
      <link>https://zyth0s.github.io/project/tight-binding-tutorial/</link>
      <pubDate>Mon, 28 Dec 2020 12:20:55 +0000</pubDate>
      <guid>https://zyth0s.github.io/project/tight-binding-tutorial/</guid>
      <description>&lt;p&gt;The tutorial is also &lt;a href=&#34;https://github.com/zyth0s/SciAlgs.jl/blob/master/src/QM/tutorial_tight_binding.ipynb&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;hosted in GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;Table of Contents&lt;/h2&gt;
&lt;nav id=&#34;TableOfContents&#34;&gt;
  &lt;ul&gt;
    &lt;li&gt;&lt;a href=&#34;#two-site-chain&#34;&gt;Two site chain&lt;/a&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#three-site-chain&#34;&gt;Three site chain&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#three-site-ring&#34;&gt;Three site ring&lt;/a&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#large-homoatomic-ring&#34;&gt;Large homoatomic ring&lt;/a&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#a-generic-tight-binding-procedure&#34;&gt;A generic tight binding procedure&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#large-chain&#34;&gt;Large chain&lt;/a&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#discrete-chain&#34;&gt;Discrete chain&lt;/a&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#two-sites-per-cell-with-s-orbitals&#34;&gt;Two sites per cell with $s$ orbitals&lt;/a&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#two-sites-per-cell-with-s-and-p-orbitals&#34;&gt;Two sites per cell with $s$ and $p$ orbitals&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#two-dimensional-lattice&#34;&gt;Two dimensional lattice&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/nav&gt;
&lt;p&gt;Tight binding is a method that expands orbitals as a linear combination of
atomic orbitals, like the method with the corresponding acronym, LCAO.
Sometimes they are refered as being the same, but let me note some differences
between them. First, LCAO often encompasses large expansions to achieve
chemical accuracy. Tight-binding, however, is more commonly used with a minimal
basis. Another difference is the reduction to an active orbital space.  The set
of orbitals is reduced in tight binding to a subset around the chemical
potential, e.g. only œÄ orbitals in a polymer chain.  In that sense, it is more
similar to H√ºckel&amp;rsquo;s method.  Also, frequently, only interactions with the first
coordination shells are included.  And finally, electron-electron interactions
are commonly neglected in tight-binding.  These differences stem from being two
similar methods used by different communities with different purposes.
Tight-binding is often a model to approximate the electronic structure of large
solid state systems, and LCAO is a good first approximation to accurately
approximate the electronic structure of small molecular systems. The chemist
tries to predict mainly reactions for whose accurate predictions are needed
whereas the physicist tries to explain features of materials in a search for
new physics laws.&lt;/p&gt;
&lt;p&gt;Most of the material of this article is inspired by a curse given by Prof.
Tjeng Hao during 2020 pandemic lockdown.&lt;/p&gt;
&lt;p&gt;We load linear algebra and plotting libraries first.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;using Pkg; Pkg.add(&amp;quot;Measures&amp;quot;)
Pkg.add(&amp;quot;Parameters&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;using LinearAlgebra
using Plots
using Measures: mm
using Parameters
import PyPlot
pyplt = PyPlot
mpl = PyPlot.matplotlib
pyplt.matplotlib.style.reload_library()
pyplt.matplotlib.style.use(&amp;quot;sci&amp;quot;)
mpl.use(backend=&amp;quot;Qt5Agg&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To plot the density of states we need to broaden/smear the spectral lines.
Note that the line shape observed experimentally is broadened by the Doppler effect among other
phenomena.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;include(&amp;quot;dos_broadening.jl&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In this tutorial we will neglect electron-electron interactions, focusing only
on kinetic electron energy and electron-external potential.  &lt;em&gt;Sites&lt;/em&gt; refers to
atoms in a lattice. Besides, we sometimes name sites rather than atomic
orbitals because we think of (atomic) orbitals as being very localized around a
site.  This also helps distinguishing atomic from molecular/crystal orbitals,
becoming simply sites and orbitals/states, respectively. Note that atomic orbitals are just
used to contruct true eigenstates of the hamiltonian considered but the earlier
are no proper states. They are used because functions with similar shape to
eigenfunctions of the Hydrogen atom hamiltonian are a good first approximation
to eigenfunctions of other hamiltonians.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;two-site-chain&#34;&gt;Two site chain&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;graph LR;
  1((1))---2((2));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A chain of two sites, one site with reference energy $0$ and the other $\Delta$ higher,
has a simple tight binding hamiltonian&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;function buildH2(Œî,t)
  # He‚Å∫
  [ 0 t; t Œî]
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;where $t$ is the hopping parameter.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;# Two atomic orbitals at sites 1 and 2
t = 0; Œî = 2
println(&amp;quot;A.1.  t = $t, Œî = $Œî&amp;quot;)
H = buildH2(Œî,t)
es, vs = eigen(H)
for i in 1:length(es)
  println(&amp;quot;Eigenstate with E = $(es[i]) and vector $(vs[i,:])&amp;quot;)
end
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;A.1.  t = 0, Œî = 2
Eigenstate with E = 0.0 and vector [1.0, 0.0]
Eigenstate with E = 2.0 and vector [0.0, 1.0]
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;example-1&#34;&gt;Example 1&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;t = 2; Œî = 0
println(&amp;quot;A.2. t = $t, Œî = $Œî&amp;quot;)
H = buildH2(Œî,t)
es, vs = eigen(H)
for i in 1:length(es)
  println(&amp;quot;Eigenstate with E = $(es[i]) and vector $(vs[i,:])&amp;quot;)
end
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;A.2. t = 2, Œî = 0
Eigenstate with E = -2.0 and vector [-0.7071067811865475, 0.7071067811865475]
Eigenstate with E = 2.0 and vector [0.7071067811865475, 0.7071067811865475]
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;example-2&#34;&gt;Example 2&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;t = 1; Œî = 10
println(&amp;quot;A.3.  t &amp;lt;&amp;lt; Œî; t = $t, Œî = $Œî&amp;quot;)
H = buildH2(Œî,t)
es, vs = eigen(H)
for i in 1:length(es)
  println(&amp;quot;Eigenstate with E = $(es[i]) and vector $(vs[i,:])&amp;quot;)
end
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;A.3.  t &amp;lt;&amp;lt; Œî; t = 1, Œî = 10
Eigenstate with E = -0.09901951359278481 and vector [-0.9951333266680701, 0.09853761796664214]
Eigenstate with E = 10.099019513592786 and vector [0.09853761796664214, 0.9951333266680701]
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;three-site-chain&#34;&gt;Three site chain&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;graph LR;
  1((1))---2((2))---3((3));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Three sites (with open boundary) and site energies $0$, $\Delta_1$, $\Delta_2$,
hoping constants $t$&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;function buildHchain3(Œî1,Œî2,t12,t23)
  [  0 t12   0;
   t12  Œî1 t23;
     0 t23  Œî2]
end
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;three-site-ring&#34;&gt;Three site ring&lt;/h2&gt;
&lt;p&gt;If the sites are forming a ring (periodic boundary conditions)
there are hoping matrix elements at the lower-left and upper-right
corners. The hamiltonian matrix is circulant rather than Toeplitz-like.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;function buildHring3(Œî1,Œî2,t12,t13,t23)
  [  0 t12 t13;
   t12  Œî1 t23;
   t13 t23  Œî2]
end
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;example-3-centers-1-electron&#34;&gt;Example: 3 centers 1 electron&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;println(&amp;quot;B.1. Œî‚ÇÅ = 2, Œî‚ÇÇ = 5, t‚ÇÅ‚ÇÇ = 1, t‚ÇÅ‚ÇÉ = 2, t‚ÇÇ‚ÇÉ = 1&amp;quot;)
H = buildHring3(2,5,1,2,1)
es, vs = eigen(H)
for i in 1:length(es)
  println(&amp;quot;Eigenstate with E = $(es[i]) and vector $(vs[i,:])&amp;quot;)
end
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;B.1. Œî‚ÇÅ = 2, Œî‚ÇÇ = 5, t‚ÇÅ‚ÇÇ = 1, t‚ÇÅ‚ÇÉ = 2, t‚ÇÇ‚ÇÉ = 1
Eigenstate with E = -0.8460273610588649 and vector [-0.932296868605906, -0.12026011521212177, 0.34111589449450974]
Eigenstate with E = 1.7430864995096744 and vector [0.22929082064416684, -0.9258926649319276, 0.3002473856565238]
Eigenstate with E = 6.102940861549199 and vector [0.2797289194129681, 0.35813444083810214, 0.890781372688963]
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;large-homoatomic-ring&#34;&gt;Large homoatomic ring&lt;/h2&gt;
&lt;p&gt;A large homoatomic ring  (circulant matrix)&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;function buildHring(t,N=1001)
  H = SymTridiagonal(zeros(N),t*ones(N-1))
  H = convert(Matrix,H)
  H[N,1] = H[1,N] = t
  H
end
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;example-without-impurity&#34;&gt;Example: without impurity&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;graph LR;
  1((1))---2((2))---3((3))---4((4))---5((...))---6((1))---7((...));
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;t = 2.5; N = 1001
println(&amp;quot;C.1. Ring with $N sites and t = $t&amp;quot;)
H = buildHring(t,N)
es, vs = eigen(H)
W = 2abs(t) # half-bandwith
band = scatter(es, xlabel=&amp;quot;Site&amp;quot;, ylabel=&amp;quot;Energy&amp;quot;,ms=2,leg=false,
               ylims=(-W-1,W+1))
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;C.1. Ring with 1001 sites and t = 2.5
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;./tutorial_tight_binding_29_1.svg&#34; alt=&#34;svg&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;e_dos, dos = dos_broadening(es)
dos = plot(dos,e_dos, ylabel=&amp;quot;Energy&amp;quot;, xlabel=&amp;quot;DOS&amp;quot;,leg=false,
            ylims=(-W-1,W+1))
l = @layout [ a b]
plot(band,dos,layout=l)
savefig(&amp;quot;../figures/C.1_bandos_ring_t=$(t)_N=$(N)_E0=0.pdf&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;example-with-an-impurity&#34;&gt;Example: with an impurity&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;graph LR;
  1((1))---2((2))---3((3))---4((4))---5((...))---6((1))---7((...));
  style 3 fill:#bbf,stroke:#f66,stroke-width:1px,color:#fff
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;# If the ring has an impurity in the middle
function buildHring_impurity(t,Œî,N=1001)
  H = SymTridiagonal(zeros(N),t*ones(N-1))
  H = convert(Matrix,H)
  H[N,1] = H[1,N] = t
  H[N√∑2,N√∑2] = Œî
  H
end
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;t = 2.5; N = 1001; Œî = -2; impuritysite = N√∑2
println(&amp;quot;C.2. Ring with $N sites with t = $t, impurity at $impuritysite Œî = $Œî&amp;quot;)
H = buildHring_impurity(t,Œî,N)
es, vs = eigen(H)
println(&amp;quot;Impurity state with E = $(es[1])&amp;quot;)
W = 2abs(t) # half-bandwith
band = scatter(es, xlabel=&amp;quot;Site&amp;quot;, ylabel=&amp;quot;Energy&amp;quot;,ms=2,leg=false,
               ylims=(-W-1,W+1))
e_dos, dos = dos_broadening(es)
dos = plot(dos,e_dos, ylabel=&amp;quot;Energy&amp;quot;, xlabel=&amp;quot;DOS&amp;quot;,leg=false,
     ylims=(-W-1,W+1))
l = @layout [ a b]
plot(band,dos,layout=l)
#savefig(&amp;quot;../figures/C.2_bandos_ring_t=$(t)_N=$(N)_E0=0_middleimpurity=$Œî.pdf&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;C.2. Ring with 1001 sites with t = 2.5, impurity at 500 Œî = -2
Impurity state with E = -5.385164807134497
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;./tutorial_tight_binding_33_1.svg&#34; alt=&#34;svg&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;plot(vs[:,1].*vs[:,1],xlims=(490,510), label=&amp;quot;Bound state&amp;quot;,
     ylabel=&amp;quot;Probability&amp;quot;,xlabel=&amp;quot;Site&amp;quot;,
     title=&amp;quot;Contribution of site orbitals to impurity state&amp;quot;)
#savefig(&amp;quot;../figures/C.2_boundstate_ring_t=$(t)_N=$(N)_E0=0_middleimpurity=$Œî.pdf&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;./tutorial_tight_binding_34_0.svg&#34; alt=&#34;svg&#34;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;a-generic-tight-binding-procedure&#34;&gt;A generic tight binding procedure&lt;/h2&gt;
&lt;p&gt;Generic function to solve tight-binding
hamiltonian, and plot bands, DOS, and PDOS.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;function tight_binding(hamiltonianConstructor::Function,params,name)
   @unpack t, N, Œî, impuritysite = params
   if ismissing(Œî)
      println(&amp;quot;$name with $N sites with t = $t&amp;quot;)
   else
      println(&amp;quot;$name with $N sites with t = $t, impurity at $impuritysite, Œî = $Œî&amp;quot;)
   end
   H = hamiltonianConstructor(params...)
   es, vs = eigen(H)
   W = 2abs(t) # half-bandwith 1D
   emargin = 1.5
   println(&amp;quot;Lowest energy state with E = $(es[1])&amp;quot;, es[1]&amp;lt;-W ? &amp;quot; (surface state)&amp;quot; : &amp;quot;&amp;quot;)
   band = scatter(es, xlabel=&amp;quot;Site&amp;quot;, ylabel=&amp;quot;Energy&amp;quot;,ms=2,leg=false,
                  ylims=(-W-emargin,W+emargin))

   e_dos, dos = dos_broadening(es)
   dos = plot(dos,e_dos, xlabel=&amp;quot;DOS&amp;quot;,leg=false,
              xlims=(0,1),ylims=(-W-emargin,W+emargin))

   e_pdos1, pdos1 = dos_broadening(es,vs[1,:].*vs[1,:])
   pdos = plot(pdos1,e_pdos1,label=&amp;quot;Site 1&amp;quot;, ylims=(-W-emargin,W+emargin))
   e_pdos500, pdos500 = dos_broadening(es,vs[N√∑2,:].*vs[N√∑2,:])
   pdos = plot!(pdos, pdos500, e_pdos500, label=&amp;quot;Site $(N√∑2)&amp;quot;,
                xlims=(0,0.0013),
                xlabel=&amp;quot;PDOS&amp;quot;)

   l = @layout [ a b c]
   plot(band,dos,pdos, layout=l, size=(1200,400),
        left_margin=5mm,bottom_margin=5mm,
        right_margin=0mm,top_margin=0mm)
   #if ismissing(impuritysite)
   #   savefig(&amp;quot;../figures/$(name)_t=$(t)_N=$(N)_E0=0.pdf&amp;quot;)
   #else
   #   savefig(&amp;quot;../figures/$(name)_t=$(t)_N=$(N)_E0=0_@$(impuritysite)=$Œî.pdf&amp;quot;)
   #end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;large-chain&#34;&gt;Large chain&lt;/h2&gt;
&lt;p&gt;A long chain considering only nearest-neighbors
hopings, all equal, with the possibility of having
an impurity in the middle&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;function buildHchain_tridiag(t,N=1001)
  H = SymTridiagonal(zeros(N),t*ones(N-1))
end
function buildHchain(t,N=1001,Œî=missing,impuritysite=missing)
  if ismissing(Œî)
     # homoatomic chain
     return buildHchain_tridiag(t,N)
  end
  H = SymTridiagonal(zeros(N),t*ones(N-1))
  H = convert(Matrix,H)
  H[impuritysite,impuritysite] = Œî
  H
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We will explore Schokley/Tamm surface states&lt;/p&gt;
&lt;h4 id=&#34;example-d1-chain-without-impurity&#34;&gt;Example D.1: Chain without impurity&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;graph LR;
  1((1))---2((2))---3((3))---4((4))---5((...))---6((N));
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;name = &amp;quot;D.1. Chain&amp;quot;
params = (t=2.5,N=1001,Œî=missing,impuritysite=missing)
tight_binding(buildHchain,params,name)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;D.1. Chain with 1001 sites with t = 2.5
Lowest energy state with E = -4.999975424409872
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;./tutorial_tight_binding_43_1.svg&#34; alt=&#34;svg&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;example-d2-impurity-in-the-middle&#34;&gt;Example D.2: Impurity in the middle&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;graph LR;
  1((1))---2((...))---3((N/2-1))---4((N/2))---5((N/2+1))---6((...))---7((N));
  style 4 fill:#bbf,stroke:#f66,stroke-width:1px,color:#fff
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;name = &amp;quot;D.2. Chain&amp;quot;
params = (t=2.5,N=1001,Œî=-2,impuritysite=500)
tight_binding(buildHchain,params,name)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;D.2. Chain with 1001 sites with t = 2.5, impurity at 500, Œî = -2
Lowest energy state with E = -5.385164807134504 (surface state)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;./tutorial_tight_binding_45_1.svg&#34; alt=&#34;svg&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;example-d3-impurity-at-the-surface&#34;&gt;Example D.3: Impurity at the surface&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;graph LR;
  1((1))---2((...))---3((N/2-1))---4((N/2))---5((N/2+1))---6((...))---7((N));
  style 1 fill:#bbf,stroke:#f66,stroke-width:1px,color:#fff
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;name = &amp;quot;D.3. Chain&amp;quot;
params = (t=2.5,N=1001,Œî=-2,impuritysite=1)
tight_binding(buildHchain,params,name)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;D.3. Chain with 1001 sites with t = 2.5, impurity at 1, Œî = -2
Lowest energy state with E = -4.99997561943913
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;./tutorial_tight_binding_47_1.svg&#34; alt=&#34;svg&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;example-d4-impurity-at-the-surface-strong-impurity&#34;&gt;Example D.4: Impurity at the surface, strong impurity&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;graph LR;
  1((1))---2((...))---3((N/2-1))---4((N/2))---5((N/2+1))---6((...))---7((N));
  style 1 fill:#bbf,stroke:#f66,stroke-width:1px,color:#fff
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;name = &amp;quot;D.4. Chain&amp;quot;
params = (t=2.5,N=1001,Œî=-4,impuritysite=1)
tight_binding(buildHchain,params,name)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;D.4. Chain with 1001 sites with t = 2.5, impurity at 1, Œî = -4
Lowest energy state with E = -5.562499999999997 (surface state)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;./tutorial_tight_binding_49_1.svg&#34; alt=&#34;svg&#34;&gt;&lt;/p&gt;
&lt;p&gt;Finite effects are also interesting&lt;/p&gt;
&lt;h2 id=&#34;discrete-chain&#34;&gt;Discrete chain&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;graph LR;
  1((1))---2((2))---3((3))---4((4))---5((5))---6((...))---9((9));
  style 1 fill:#bbf,stroke:#f66,stroke-width:1px,color:#fff
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;example-e1-weak-impurity&#34;&gt;Example E.1: Weak impurity&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;name = &amp;quot;E.1. Finite Chain&amp;quot;
params = (t=2.5,N=9,Œî=-2,impuritysite=1)
tight_binding(buildHchain,params,name)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;E.1. Finite Chain with 9 sites with t = 2.5, impurity at 1, Œî = -2
Lowest energy state with E = -4.853039707148026
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;./tutorial_tight_binding_52_1.svg&#34; alt=&#34;svg&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;example-e2-strong-impurity&#34;&gt;Example E.2: Strong impurity&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;name = &amp;quot;E.2. Finite Chain&amp;quot;
params = (t=2.5,N=9,Œî=-4,impuritysite=1)
tight_binding(buildHchain,params,name)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;E.2. Finite Chain with 9 sites with t = 2.5, impurity at 1, Œî = -4
Lowest energy state with E = -5.562184783729448 (surface state)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;./tutorial_tight_binding_54_1.svg&#34; alt=&#34;svg&#34;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;two-sites-per-cell-with-s-orbitals&#34;&gt;Two sites per cell with $s$ orbitals&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;function tight_binding_1D_2sites(a,Œî‚ÇÅ‚ÇÇ,t)
   # 1D chain/ring with 2 sites per unit cell, s orbitals
   b = 2a # unit cell with two sites
   Œµ1 = 0 # without loss of generality energy reference at 0
   Œµ2 = Œî‚ÇÅ‚ÇÇ

   kpath = range(-œÄ/b,œÄ/b,length=100)
   Enk = zeros(2,length(kpath))

   for (ik,k) in enumerate(kpath)
      H_k = [     Œµ1        2t*cos(k*a);
              2t*cos(k*a)       Œµ2      ]
      e, vs = eigen(H_k)
      Enk[:,ik] = e
   end

   plot(kpath/œÄ,[Enk[1,:], Enk[2,:]],
        label=[&amp;quot;Ground state&amp;quot; &amp;quot;Excited state&amp;quot;],
        xlabel=&amp;quot;k pi/a&amp;quot;, ylabel=&amp;quot;Energy&amp;quot;,
        leg = :inside,
       )
   #savefig(&amp;quot;../figures/1d_2sites.pdf&amp;quot;)
end
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;example&#34;&gt;Example&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;tight_binding_1D_2sites(1,2,2) # a, Œî‚ÇÅ‚ÇÇ, t
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;./tutorial_tight_binding_58_0.svg&#34; alt=&#34;svg&#34;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;two-sites-per-cell-with-s-and-p-orbitals&#34;&gt;Two sites per cell with $s$ and $p$ orbitals&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;function tight_binding_1D_2sites_sp_orbs(a,Œî‚ÇÅ‚ÇÇ,t)
   # 1D chain/ring with 2 sites per unit cell, sp orbitals
   # Redefined œàpk = i 1/‚àöN * ‚àëR‚ÇÇ exp(ikR‚ÇÇ) œïp(r-R‚ÇÇ) to have a real matrix
   b = 2a # unit cell with two sites
   Œµs = Œî‚ÇÅ‚ÇÇ
   Œµp = 0 # without loss of generality energy reference at 0

   kpath = range(-œÄ/b,œÄ/b,length=100)
   Enk = zeros(2,length(kpath))

   for (ik,k) in enumerate(kpath)
      H_k = [      Œµs        -2t*sin(k*a);
              -2t*sin(k*a)        Œµp      ]
      e, vs = eigen(H_k)
      Enk[:,ik] = e
   end

   plot(kpath/œÄ,[Enk[1,:], Enk[2,:]],
        label=[&amp;quot;p state&amp;quot; &amp;quot;s state&amp;quot;],
        xlabel=&amp;quot;k pi/a&amp;quot;, ylabel=&amp;quot;Energy&amp;quot;,
        leg = :right,
       )
   #savefig(&amp;quot;../figures/1d_2sites_sp_orbs.pdf&amp;quot;)
end
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;tight_binding_1D_2sites_sp_orbs(1,2,2) # a, Œî‚ÇÅ‚ÇÇ, t
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;./tutorial_tight_binding_61_0.svg&#34; alt=&#34;svg&#34;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;two-dimensional-lattice&#34;&gt;Two dimensional lattice&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;function tight_binding_2D(a,b,Œî‚ÇÅ‚ÇÇ,ta,tb)
   # 2D rectangular lattice with 1 site per unit cell, s orbitals
   @assert a == b # does not handle rectangular with analytic formula
   @assert Œî‚ÇÅ‚ÇÇ == 0 # does not handle ‚â† Œµ with analytic formula
   Œµ1 = 0 # without loss of generality energy reference at 0
   Œµ2 = Œî‚ÇÅ‚ÇÇ

   Hamiltonian(kx,ky) = [               Œµ1               2ta*cos(kx*a) + 2tb*cos(ky*b);
                         2ta*cos(kx*a) + 2tb*cos(ky*b)                  Œµ2            ]

   # ............................
   # Band plot
   nkpts = 100
   kpath = zeros(2,3nkpts)
   kpath[1,  1:nkpts]  = range(0,œÄ/a,length=nkpts)
   kpath[2,  1:nkpts] .= 0
   #
   kpath[1,(nkpts+1):2nkpts] .= œÄ/a
   kpath[2,(nkpts+1):2nkpts]  = range(0,œÄ/b,length=nkpts)
   #
   kpath[1,(2nkpts+1):3nkpts]  = range(œÄ/a,0,length=nkpts)
   kpath[2,(2nkpts+1):3nkpts]  = range(œÄ/b,0,length=nkpts)
   Enk = zeros(2,3nkpts)

   for ik in 1:3nkpts
      kx = kpath[1,ik]
      ky = kpath[2,ik]
      H_k = Hamiltonian(kx,ky)
      e, vs = eigen(H_k)
      #Enk[:,ik] = e # FIXME
      Enk[1,ik] = Œµ1 + Œµ2 - 2abs(ta)*cos(kx*a) - 2abs(tb)*cos(ky*b) # analytic formula
   end

   #plot(1:3nkpts,[Enk[1,:],Enk[2,:]],
   #plot(1:3nkpts,Enk[1,:],
   #     label=[&amp;quot;Ground state&amp;quot; &amp;quot;Excited state&amp;quot;],
   #     xlabel=&amp;quot;kpath/pi&amp;quot;, ylabel=&amp;quot;Energy&amp;quot;,
   #     leg = :inside,
   #    )
   #savefig(&amp;quot;2d_1sites.pdf&amp;quot;)
   fig = pyplt.figure()
   fig.set_dpi(260)
   ax = fig.add_subplot(111)
   ax.plot(1:3nkpts,Enk[1,:], label=&amp;quot;Ground state&amp;quot;)
   ax.xaxis.set_major_locator(mpl.ticker.MultipleLocator(100))
   ax.set_xticklabels([&amp;quot;d&amp;quot;,&amp;quot;(0,0)T&amp;quot;, &amp;quot;(1,0)T&amp;quot;, &amp;quot;(1,1)T&amp;quot;, &amp;quot;(0,0)T&amp;quot;])
   ax.set_xlim(0,3nkpts)
   ax.set_ylim(-2abs(ta)-2abs(tb),2abs(ta)+2abs(tb))
   ax.grid(true)
   ax.set_xlabel(&amp;quot;(kx,ky)T pi/a&amp;quot;)
   ax.set_ylabel(&amp;quot;Energy&amp;quot;)
   fig.tight_layout(pad=0.1)
   pyplt.savefig(&amp;quot;../figures/2d_1sites.pdf&amp;quot;)

   # ..........................................................
   # BZ integration
   nmesh = 101
   Enk = zeros(2,nmesh,nmesh)
   kxrange = range(-œÄ/a,œÄ/a,length=nmesh)
   kyrange = range(-œÄ/b,œÄ/b,length=nmesh)
   for (ikx,kx) in enumerate(kxrange), 
       (iky,ky) in enumerate(kyrange)
      H_k = Hamiltonian(kx,ky)
      #e, vs = eigen(H_k) # FIXME
      ##_,_,eschur = schur(H_k)
      Enk[1,ikx,iky] = Œµ1 + Œµ2 - 2abs(ta)*cos(kx*a) - 2abs(tb)*cos(ky*b) # analytic result a = b; ...
      #if abs(kx) + abs(ky) &amp;lt; pi/a
      #   Enk[:,ikx,iky] = e
      #else
      #   Enk[:,ikx,iky] = reverse(e)
      #end
      #isapprox(e[1] , Œµ1 + Œµ2 + 2ta*cos(kx*a) + 2tb*cos(ky*b), atol=1e-1) || error(&amp;quot;wrong eigenvalue $(e[1]) ‚â† $(Œµ1 + Œµ2 + 2ta*cos(kx*a) + 2tb*cos(ky*b))&amp;quot;)
      #@show kx, ky
      #println(e[1],&amp;quot; &amp;quot;, e[2], &amp;quot; &amp;quot;, Œµ1 + Œµ2 - 2abs(ta)*cos(kx*a) - 2abs(tb)*cos(ky*b))
      #e[1], e[2] = e[2], e[1]
   end

   fig = pyplt.figure()
   fig.set_dpi(260)
   ax = fig.add_subplot(111)
   ax.set_aspect(&amp;quot;equal&amp;quot;)
   cont = ax.contourf(kxrange./œÄ,kyrange./œÄ,Enk[1,:,:], levels=15)
   #cont = ax.plot_surface(kxrange./œÄ,kyrange./œÄ,Enk[1,:,:])
   #cont = ax.imshow(Enk[1,:,:],extent=(-1,1,-1,1))
   # Set axis labels
   ax.set_xlabel(&amp;quot;kx pi/a&amp;quot;)
   ax.set_ylabel(&amp;quot;ky pi/b&amp;quot;)
   pyplt.colorbar(cont,format=&amp;quot;%+3.1f&amp;quot;)
   fig.tight_layout(pad=0.1)
   pyplt.savefig(&amp;quot;../figures/2d_1sites_contour.pdf&amp;quot;)
end
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;tight_binding_2D(1,1,0,1,1) # a, b, Œî‚ÇÅ‚ÇÇ, ta, tb
#tight_binding_2D(10,5,2,0.5,1) # a, b, Œî‚ÇÅ‚ÇÇ, ta, tb
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;./tutorial_tight_binding_64_0.png&#34; alt=&#34;png&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;./tutorial_tight_binding_64_1.png&#34; alt=&#34;png&#34;&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Spectral decomposition with Julia</title>
      <link>https://zyth0s.github.io/post/spectral-decomposition-with-julia/</link>
      <pubDate>Mon, 28 Dec 2020 11:26:52 +0000</pubDate>
      <guid>https://zyth0s.github.io/post/spectral-decomposition-with-julia/</guid>
      <description>&lt;p&gt;We briefly discuss how to eigendecompose a symmetric square matrix, and check some of its properties.&lt;/p&gt;
&lt;p&gt;Note about notation:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;vectors are bold lowercase, like $\mathbf{u,v}$.&lt;/li&gt;
&lt;li&gt;matrices are bold uppercase, like $\mathbf{A,B,C}$.&lt;/li&gt;
&lt;li&gt;scalars are lowercase, like $x,y,z$.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&#39;&lt;/code&gt; means (i) the complex conjugate for scalars, or (ii) the (conjugate) transpose for vectors/matrices.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;using LinearAlgebra: eigen, Diagonal, I, det, rank
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Given an ordered basis every linear mapping has a unique transformation matrix.
A way to characterize the matrix representation of the linear mapping is by how
it transforms vectors. It turns out that we can find a set of special vectors
that are just scaled by some &lt;em&gt;eigenvalue&lt;/em&gt; when we apply the linear mapping to them.&lt;/p&gt;
&lt;p&gt;Lets take a $4 \times 4$ matrix,&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;A = rand(4,4)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;that is symmetric (or hermitic if elements were complex)&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;A = (A + A&#39;)/2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A $4 \times 4$ matrix has 4 eigenvalues $(e_1,e_2,e_3,e_4)$
and 4 respective eigenvectors $(\mathbf{v}_1,\mathbf{v}_2,\mathbf{v}_3,\mathbf{v}_4)$&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;e, U = eigen(A) # solves $Av = ev$
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;eigen&lt;/code&gt; returns the eigenvalues in a vector &lt;code&gt;e&lt;/code&gt; and
the eigenvectors as columns of a matrix &lt;code&gt;U&lt;/code&gt;.
E.g. the first eigenvalue is $e_1 =$ &lt;code&gt;e[1]&lt;/code&gt; and the first
eigenvector is $\mathbf{v}_1 =$ &lt;code&gt;U[:,1]&lt;/code&gt;.
Note that eigenvalues are ordered in descending order and eigenvectors
reflect this reordering.&lt;/p&gt;
&lt;p&gt;We can check that the secular equation $|\mathbf{A} - e_i\mathbf{I}| = 0$ is satisfied (for each eigenvalue)&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;for i in 1:4
   isapprox( det(A - e[i]*I), 0.00, atol=1e-4) || error(&amp;quot;Secular equation $i not satisfied&amp;quot;)
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The corresponding eigenvectors satisfy $(\mathbf{A} - e_i\mathbf{I})\mathbf{v} = \mathbf{0}$&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;for i in 1:4
   isapprox( (A - e[i]*I)*U[:,i], fill(0.00,4), atol=1e-4) || error(&amp;quot;a) Eigenvalue equation $i not satisfied&amp;quot;)
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;or equivalently $\mathbf{A}\mathbf{v} = e_i\mathbf{v}$&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;for i in 1:4
   isapprox( A*U[:,i], e[i]*U[:,i], atol=1e-4) || error(&amp;quot;b) Eigenvalue equation $i not satisfied&amp;quot;)
end
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;If $\mathbf{A}$ is symmetric, thus $\mathbf{U}$ is orthonormal and $\mathbf{U}&#39; = \mathbf{U}^{-1}$&lt;/li&gt;
&lt;li&gt;If $\mathbf{A}$ is hermitic, thus $\mathbf{U}$ is unitary and $\mathbf{U}&#39; = \mathbf{U}^{-1}$&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In both cases it can be described as a similarity transformation
$$ \mathbf{A} = \mathbf{U} \mathbf{D} \mathbf{U}^{-1} = \mathbf{U} \mathbf{D} \mathbf{U}&#39; $$
where $\mathbf{D}$ is a diagonal matrix with the eigenvalues as diagonal elements.
Therefore, $\mathbf{D}$ is the matrix that diagonalizes $\mathbf{A}$.
$\mathbf{A}$ and $\mathbf{D}$ are said to be similar matrices.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;A ‚âà U * Diagonal(e) * U&#39; || error(&amp;quot;Not a similarity transformation&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A similarity transformation is also a conformal mapping. A matrix $\mathbf{W}$
encoding a crystallographic symmetry operation is an isometry if
$$ \mathbf{G} \approx \mathbf{W} \mathbf{G} \mathbf{W}&#39; $$
where $\mathbf{G}$ is the metric tensor.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Solar System Simulation</title>
      <link>https://zyth0s.github.io/project/solar-system-simulation/</link>
      <pubDate>Mon, 28 Dec 2020 08:25:09 +0000</pubDate>
      <guid>https://zyth0s.github.io/project/solar-system-simulation/</guid>
      <description>&lt;p&gt;A &lt;a href=&#34;https://github.com/zyth0s/SciAlgs.jl/blob/master/src/Astro/planets_motion.jl&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;script&lt;/a&gt; to simulate planet motion. Plots the solar system at a given moment in time.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Quantum Teleportation Tutorial</title>
      <link>https://zyth0s.github.io/project/quantum-teleportation-tutorial/</link>
      <pubDate>Mon, 28 Dec 2020 00:13:44 +0000</pubDate>
      <guid>https://zyth0s.github.io/project/quantum-teleportation-tutorial/</guid>
      <description>&lt;p&gt;The tutorial is also &lt;a href=&#34;https://github.com/zyth0s/SciAlgs.jl/blob/master/src/QM/tutorial_quantum_computing.ipynb&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;hosted in
GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Have you ever heard of quantum teleportation and wondered what is it exactly?
Until very recently I was like you.  Even if I received academic formation
(including quantum mechanics) I never got past pure astonishment. For instance,
once I opened a quantum information book at a public library and I was scared
enough to not look further. On the other hand, popular explanations of the
concept always fail to give a satisfactory description because they omit the
only tool that helps us understand quantum mechanics: math.&lt;/p&gt;
&lt;p&gt;My perspective changed completely when I encountered Nielsen and Matuschak&amp;rsquo;s
&lt;a href=&#34;https://quantum.country/qcvc&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Quantum Computing for the very curious&lt;/a&gt;
fantastic essays. I encourage you to read them also.&lt;/p&gt;
&lt;p&gt;As you will discover, most of the calculations can be reduced to simple low
dimensional matrix operations. It is ideal for tinkering.  Furthermore, the
whole teleportation protocol can be condensed into a single diagram.&lt;/p&gt;
&lt;p&gt;In this hands-out tutorial we will cover some of the same concepts with the
help of a computer. All code below is written in Julia.  Few linear algebra
concepts are needed. We use the identity matrix $I_m$, the adjoint operation
$A^\dagger$, the determinant, trace, kroenecker (or tensor) product, and the
2-norm.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;using LinearAlgebra: I, det, tr, kron, normalize!
const ‚äó = kron
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;computational-quantum-basis&#34;&gt;Computational quantum basis&lt;/h2&gt;
&lt;p&gt;Digital computers are able to reduce all information to zeros and ones, that
is, a bit may be one of the set ${0, 1}$. The measurement of a single bit is
described by a probability distribution on the space of possible bits $p:
{0,1} \to [0,1]$. On the other hand, quantum bits belong to a two-dimensional
complex vector space $\mathbb{C}^2$. Measurements give also a probability but
draw from a larger space $\rho_p: \mathbb{C}^2 \to [0,1]$.&lt;/p&gt;
&lt;p&gt;Now you might ask how to move data stored in bits to qubits. It turns out that
you can map every classical probability distribution to a quantum probability
distribution. The resulting distribution is called a density operator,
$\rho_p$. If we think of each element of the bitset ${0,1}$ as a $2 \times 1$
basis vector, both form an orthonormal basis that spans $\mathbb{C}^2$.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$|0\rangle = [1, 0]^T$ is a column vector representing the classical bit 0&lt;/li&gt;
&lt;li&gt;$|1\rangle = [0, 1]^T$ is a column vector representing the classical bit 1&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Column vectors are represented with the bar and right bracket, e.g.
$|v\rangle$, following in Dirac notation. Those two special vectors will be
assigned in code to unicode characters that ressemble $0$ and $1$.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;ùüé = [1, 0] # ‚â° $|0\rangle$; typeset with \bfzero
ùüè = [0, 1] # ‚â° $|1\rangle$; typeset with \bfone
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The density operator is the $2 \times 2$ matrix with the classical
probabilities arranged along its diagonal, the rest zeros. If we have a
classical bit 0 (probability $p=1$ to have $|0\rangle$ and $p=0$ to have
$|1\rangle$), then the density operator is&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;œÅùüé = [1 0;
      0 0]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Other way to map classical to quantum probabilities is using the outer product
$\rho_p = \sum_i p_i |\psi_i\rangle \langle\psi_i|$&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;@assert œÅùüé ‚âà 1ùüé*ùüé&#39; + 0ùüè*ùüè&#39; # ùüé has p=1, and ùüè has p=0 probability
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The vector with left angle and bar is a row vector that is the adjoint of the
corresponding column vector.&lt;/p&gt;
&lt;p&gt;The same probability distribution can be arranged as a vector if we had
chosen the tensor product instead of the outer product. Instead of a $2
\times 2$ matrix we have a $4 \times 1$ vector. Technically, a vector space
like $\mathbb{C}^2$ is isomorphic to $\mathbb{C} \otimes \mathbb{C}$.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;@assert vec(œÅùüé) ‚âà 1ùüé ‚äó ùüé + 0ùüè ‚äó ùüè
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;a-general-qubit&#34;&gt;A general qubit&lt;/h3&gt;
&lt;p&gt;A general qubit $|\psi\rangle = \alpha |0\rangle + \beta |1\rangle \in
\mathbb{C}^2$ is described as a linear combination of the basis vectors and
it must satisfy the normalization condition $|\alpha|^2 + |\beta|^2 = 1$.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;Œ± = 0.6
Œ≤ = 0.8
@assert Œ±^2 + Œ≤^2 ‚âà 1 # normalization contraint (here for Œ±, Œ≤ ‚àà ‚Ñù)
œà = Œ±*ùüé + Œ≤*ùüè
@assert œà ‚âà [Œ±, Œ≤]
@assert œà&#39;*œà ‚âà 1 # ‚ü®œà|œà‚ü© = 1 (normalization again)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;quantum-gates&#34;&gt;Quantum gates&lt;/h2&gt;
&lt;p&gt;Once we have transformed our information to qubits we need to manipulate them
to achieve our goal. Those operations are realized with gates that are
analogous to classical circuit gates.&lt;/p&gt;
&lt;h3 id=&#34;pauli-sigma_x-gate-x--not------x----&#34;&gt;Pauli $\sigma_x$ gate: &lt;code&gt;X == NOT == ---[ X ]---&lt;/code&gt;&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;X = [0 1; 1 0]
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;@assert X*ùüé ‚âà ùüè
@assert X*ùüè ‚âà ùüé
# By the linearity of matrix multiplication it follows that the matrix acts the
# same way as the X on all input states, and so they are the same operation.
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;@assert X*X&#39; ‚âà I(2) # this is a proof of unitariness
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;X*œà
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;2-element Array{Float64,1}:
 0.8
 0.6
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;hadamard-gate--h------h----&#34;&gt;Hadamard gate:  &lt;code&gt;H == ---[ H ]---&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;A Hadamard gate converts a classical bit into a general qubit.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;H = [1 1; 1 -1]./‚àö2
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;@assert H*ùüé ‚âà [1, 1]./‚àö2 # kinda bonding state
@assert H*ùüè ‚âà [1,-1]./‚àö2 # kinda antibonding state
# By the linearity of matrix multiplication it follows that the matrix acts the
# same way as the Hadamard on all input states, and so they are the same
# operation.
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;@assert H^2 ‚âà I(2) # H is idempotent
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;@assert H*H&#39; ‚âà I(2) # this is a proof of unitariness
@assert abs(det(H)) ‚âà 1 # conservation of particles
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Not every matrix is a gate, for instance&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;J = [1 1; 1 1]./‚àö2
@assert (J*J&#39; ‚âà I(2)) == false
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;H X œà == &amp;mdash;[ X ]&amp;mdash;[ H ]&amp;mdash;&lt;/p&gt;
&lt;h3 id=&#34;measurement-----m-&#34;&gt;Measurement: &lt;code&gt;---| m )===&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;In colloquial terms, measurements can be performed by &amp;ldquo;casting the shadow&amp;rdquo; of the qubit state at a
place where we can look, that is, our computational quantum basis.  The
probability of $|u\rangle$ being $|0\rangle$ is $\langle u|0\rangle\langle
0|u\rangle = |\langle 0|u\rangle|^2$ or $Tr(\rho_u |0\rangle\langle 0|)$ where
$\rho_u$ is the density operator $|u\rangle\langle u|$.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;measure(œà, verbose=false) = begin
   pùüé = tr(œà*œà&#39; * ùüé*ùüé&#39;) # ‚â° ‚ü®œà|0‚ü©‚ü®0|œà‚ü© resol. ident
   pùüè = tr(œà*œà&#39; * ùüè*ùüè&#39;) # ‚â° ‚ü®œà|1‚ü©‚ü®1|œà‚ü© resol. ident
   if verbose
      println(&amp;quot;m = 0 with probability $pùüé&amp;quot;)
      println(&amp;quot;m = 1 with probability $pùüè&amp;quot;)
   end
   [pùüé, pùüè]
end
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;# _œà2 ---[ H ]---[ m )===
_œà = rand([ùüé,ùüè])
_œà2 = H*_œà # Input state is either (|0‚ü© + |1‚ü©)/‚àö2 or (|0‚ü© - |1‚ü©)/‚àö2
H*_œà2 |&amp;gt; measure
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;2-element Array{Float64,1}:
 0.0
 0.9999999999999996
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The state measured is the same as the initial one. That is a consequence of $H$ being
idempotent.&lt;/p&gt;
&lt;h3 id=&#34;pauli-sigma_y-gate--y------y----&#34;&gt;Pauli $\sigma_y$ gate:  &lt;code&gt;Y == ---[ Y ]---&lt;/code&gt;&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;Y = [0 -im; im 0]
@assert Y*Y&#39; ‚âà I(2)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;pauli-sigma_z-gate-z------z----&#34;&gt;Pauli $\sigma_z$ gate: &lt;code&gt;Z == ---[ Z ]---&lt;/code&gt;&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;Z = [1 0; 0 -1]
@assert Z*Z&#39; ‚âà I(2)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;general-rotation-gate&#34;&gt;General rotation gate&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;Œ∏ = œÄ/2
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;R = [cos(Œ∏) -sin(Œ∏); sin(Œ∏) cos(Œ∏)]
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;2√ó2 Array{Float64,2}:
 6.12323e-17  -1.0
 1.0           6.12323e-17
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;@assert R*R&#39; ‚âà I(2)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;Rx(Œ∏) = cos(Œ∏/2)*I(2) - im * sin(Œ∏/2)*X
Ry(Œ∏) = cos(Œ∏/2)*I(2) - im * sin(Œ∏/2)*Y
Rz(Œ∏) = cos(Œ∏/2)*I(2) - im * sin(Œ∏/2)*Z
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;multi-qubit-states&#34;&gt;Multi-qubit states&lt;/h2&gt;
&lt;p&gt;Here again, we can find an analogy with the classical world if we think that
we are passing from sets to vector spaces. Whereas classical state spaces are
combined with the cartesian product, such as ${0,1} \times {0,1}$,
quantum state spaces are combined with the tensor product, $\mathbb{C}^2 ‚äó
\mathbb{C}^2$. The classical probability $p: {0,1} \times {0,1} \to
[0,1]$ on the combined set is a joint probability (the probability of
both having 0 in the first and 0 in the second bit, for example). The
corresponding density operator is also a joint probability in their
tensor product space $\rho_p: \mathbb{C}^2 \otimes \mathbb{C}^2 \cong
\mathbb{C}^4 \to [0,1]$.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;ùüéùüé = ùüé ‚äó ùüé
ùüéùüè = ùüé ‚äó ùüè
ùüèùüé = ùüè ‚äó ùüé
ùüèùüè = ùüè ‚äó ùüè
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;Œ≥ = 0.8
Œ¥ = 0.6
œï = Œ≥*ùüé + Œ¥*ùüè
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;2-element Array{Float64,1}:
 0.8
 0.6
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;More generally, if we have single-qubit states œà and œï, then the combined
state when the two qubits are put together is just:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;Œæ = œà ‚äó œï
@assert Œæ ‚âà [œà[1]*œï[1], œà[1]*œï[2], œà[2]*œï[1], œà[2]*œï[2]]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;multi-qubit-gates&#34;&gt;Multi-qubit gates&lt;/h2&gt;
&lt;p&gt;Take the form  $G_1 \otimes G_2 \otimes \cdots$.&lt;/p&gt;
&lt;h3 id=&#34;controlled-not-gate-cnot&#34;&gt;Controlled-NOT gate (CNOT)&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;  x ---‚ãÖ---
       |
  y ---‚äï---
  x is the control qubit
  y is the target qubit
  |x, y ‚äï x‚ü© for short
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;CNOT = [1 0 0 0;
        0 1 0 0;
        0 0 0 1;
        0 0 1 0]
# Also
@assert CNOT ‚âà cat(I(2), X, dims=(1,2)) #|&amp;gt; Matrix
@assert CNOT ‚âà ùüé*ùüé&#39; ‚äó I(2) + ùüè*ùüè&#39; ‚äó X
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;@assert CNOT*ùüéùüé ‚âà ùüéùüé
@assert CNOT*ùüéùüè ‚âà ùüéùüè
@assert CNOT*ùüèùüé ‚âà ùüèùüè
@assert CNOT*ùüèùüè ‚âà ùüèùüé
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;# Apply H to first qubit in a 2d space
H‚ÇÅ = H ‚äó I(2)
# Apply H to second qubit in a 2d space
H‚ÇÇ = I(2) ‚äó H
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;4√ó4 Array{Float64,2}:
 0.707107   0.707107  0.0        0.0
 0.707107  -0.707107  0.0        0.0
 0.0        0.0       0.707107   0.707107
 0.0        0.0       0.707107  -0.707107
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;CNOT*H‚ÇÅ*ùüéùüé
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;4-element Array{Float64,1}:
 0.7071067811865475
 0.0
 0.0
 0.7071067811865475
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Beware, CNOT can change the control qubit!&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;# |+-‚ü©
pm = H*ùüé ‚äó H*ùüè
# |--‚ü©
mm = H*ùüè ‚äó H*ùüè
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;|0‚ü© ---[ H ]--- |+‚ü©---‚ãÖ--- |-‚ü©
                      |
|1‚ü© ---[ H ]--- |-‚ü©---‚äï--- |-‚ü©
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;@assert CNOT*pm ‚âà mm
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;toffoli-gate-ccnot&#34;&gt;Toffoli gate CCNOT&lt;/h2&gt;
&lt;p&gt;Replaces the classical AND gate&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;#CCNOT = cat(I(6), [0 1; 1 0], dims=(1,2)) |&amp;gt; Matrix
CCNOT = cat(I(4), CNOT, dims=(1,2)) |&amp;gt; Matrix
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;8√ó8 Array{Int64,2}:
 1  0  0  0  0  0  0  0
 0  1  0  0  0  0  0  0
 0  0  1  0  0  0  0  0
 0  0  0  1  0  0  0  0
 0  0  0  0  1  0  0  0
 0  0  0  0  0  1  0  0
 0  0  0  0  0  0  0  1
 0  0  0  0  0  0  1  0
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;global-phase-factor&#34;&gt;Global phase factor&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;Œ∏ = rand() # any real number
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;0.24805413652694797
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;G(Œ∏) = ‚ÑØ^(im*Œ∏) * I(2) # global phase factor ‚ÑØ^(iŒ∏)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;if typeof(Œ∏) &amp;lt;: Real
   @assert G(Œ∏)*G(Œ∏)&#39; ‚âà I(2)
   @info &amp;quot;A matrix changing the global phase factor is unitary.&amp;quot;
end
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;‚îå Info: A matrix changing the global phase factor is unitary.
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;@info &amp;quot;Changing the phase does not affect the measurement.&amp;quot;
@assert G(rand())*ùüé |&amp;gt; measure ‚âà measure(ùüé)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;‚îå Info: Changing the phase does not affect the measurement.
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;other-gates&#34;&gt;Other gates&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;S = [ 1 0; 0 im]
T = [ 1 0; 0 ‚ÑØ^(im*œÄ/4)]
#Y = [ 0 -im; im 0]
#Z = [ 1 0; 0 -1]
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;2√ó2 Array{Complex{Float64},2}:
 1.0+0.0im       0.0+0.0im
 0.0+0.0im  0.707107+0.707107im
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you were able to follow me you are ready to understand quantum teleportation.&lt;/p&gt;
&lt;h2 id=&#34;quantum-teleportation&#34;&gt;Quantum teleportation&lt;/h2&gt;
&lt;p&gt;Alice and Bob can share &lt;em&gt;beforehand&lt;/em&gt; a special entangled two-qubit&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;|0‚ü© ---[ H ]---‚ãÖ--- 
               |   
               |    (|00‚ü© + |11‚ü©)/‚àö2
               |
|0‚ü© -----------‚äï---
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;ebit = CNOT*H‚ÇÅ*ùüéùüé # entangled bit -&amp;gt; shared
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;4-element Array{Float64,1}:
 0.7071067811865475
 0.0
 0.0
 0.7071067811865475
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Alice takes the upper qubit and Bob the lower qubit.
Then, they can separate.&lt;/p&gt;
&lt;p&gt;That is the first stage of the protocol depicted below&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;         teleported state:  |œà‚ü©  ------‚ãÖ---[ H ]---[ z )===
                                       |
                                       |
                                       |
       |0‚ü© ---[ H ]---‚ãÖ----------------‚äï-----------[ x )===
                      |  |00‚ü© + |11‚ü©
                      | ------------
                      |      ‚àö2
       |0‚ü© -----------‚äï------------------------------------[ XÀ£ ]---[ Z·∂ª ]--- |œà‚ü©
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It is a very succint way of condensing an otherwise unexpeced phenomenom.&lt;/p&gt;
&lt;p&gt;Given the moment, Alice will desire to deliver Bob some important piece of information
encoded as a qubit.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;# The state œà Alice wants to teleport
Œ± = rand(Complex{Float64})
Œ≤ = sqrt(1 - Œ±*conj(Œ±)) # |Œ±|¬≤ + |Œ≤|¬≤ = 1
@assert Œ±*conj(Œ±) + Œ≤*conj(Œ≤) ‚âà 1 &amp;quot;State not properly normalized. Try with other (Œ±,Œ≤)&amp;quot;
œà = Œ±*ùüé + Œ≤*ùüè # ‚àà ‚ÑÇ¬≤ ‚âù ‚ÑÇ ‚äó ‚ÑÇ ; œÅœà = œà*œà&#39; ‚àà ‚ÑÇ ‚äó ‚ÑÇ
_œà = œà # we can do this only in a classic circuit (debugging purposes)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;2-element Array{Complex{Float64},1}:
    0.75190393025605 + 0.5381299416639849im
 0.38086302728175303 + 0.0im
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;She applies a conditional-NOT to the entangled qubit based on the state to be
teleported. Thus, both are entangled. Next, applies a Hadamard matrix to the state to be teleported.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;s = œà ‚äó ebit;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;gate1 = CNOT ‚äó I(2)
gate2 = H ‚äó I(4);
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;œà = gate2*gate1*s;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Alice measures first two bits, posibilities are 00, 01, 10, and 11&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;Pùüéùüé = ùüéùüé*ùüéùüé&#39; ‚äó I(2) # projections
Pùüéùüè = ùüéùüè*ùüéùüè&#39; ‚äó I(2)
Pùüèùüé = ùüèùüé*ùüèùüé&#39; ‚äó I(2)
Pùüèùüè = ùüèùüè*ùüèùüè&#39; ‚äó I(2);
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;œÅœà = œà*œà&#39; # density operator
pùüéùüé = tr(œÅœà * Pùüéùüé) |&amp;gt; real # probabilities
pùüéùüè = tr(œÅœà * Pùüéùüè) |&amp;gt; real
pùüèùüé = tr(œÅœà * Pùüèùüé) |&amp;gt; real
pùüèùüè = tr(œÅœà * Pùüèùüè) |&amp;gt; real;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;@info &amp;quot;  The probability of |ùüéùüé‚ü© is $pùüéùüé&amp;quot;
@info &amp;quot;  The probability of |ùüéùüè‚ü© is $pùüéùüè&amp;quot;
@info &amp;quot;  The probability of |ùüèùüé‚ü© is $pùüèùüé&amp;quot;
@info &amp;quot;  The probability of |ùüèùüè‚ü© is $pùüèùüè&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;‚îå Info:   The probability of |ùüéùüé‚ü© is 0.2499999999999999
‚îå Info:   The probability of |ùüéùüè‚ü© is 0.2499999999999999
‚îå Info:   The probability of |ùüèùüé‚ü© is 0.2499999999999999
‚îå Info:   The probability of |ùüèùüè‚ü© is 0.2499999999999999
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;All outcomes have the same chance of appearing.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;icollapsed = argmax([pùüéùüé, pùüéùüè, pùüèùüé, pùüèùüè])
icollapsed = rand(1:4) # to avoid taking always the first
Pcollapsed = [Pùüéùüé, Pùüéùüè, Pùüèùüé, Pùüèùüè][icollapsed];
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;x = (icollapsed == 2 || icollapsed == 4) |&amp;gt; Int
z = (icollapsed == 3 || icollapsed == 4) |&amp;gt; Int
@info &amp;quot;  Alice measured x = $x and z = $z&amp;quot;
@info &amp;quot;  Alice qubits collapsed to $([&amp;quot;|ùüéùüé‚ü©&amp;quot;, &amp;quot;|ùüéùüè‚ü©&amp;quot;, &amp;quot;|ùüèùüé‚ü©&amp;quot;, &amp;quot;|ùüèùüè‚ü©&amp;quot;][icollapsed])&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;‚îå Info:   Alice measured x = 1 and z = 0
‚îå Info:   Alice qubits collapsed to |ùüéùüè‚ü©
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The resulting two classical bits are shared to Bob, who uses them to process
his entangled bit.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;range = 2icollapsed-1:2icollapsed
œà = normalize!(Pcollapsed*œà)[range] # state after measurement of ùüéùüé
œà = Z^z * X^x * œà # Bob uses Alice classical bits x and z
@assert _œà ‚âà œà &amp;quot;Teleported state has been corrupted&amp;quot;
@info &amp;quot;  Teleported |œà‚ü© = ($(œà[1])) |ùüé‚ü© + ($(œà[2])) |ùüè‚ü© !!&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;‚îå Info:   Teleported |œà‚ü© = (0.75190393025605 + 0.5381299416639849im) |ùüé‚ü© + (0.3808630272817531 + 0.0im) |ùüè‚ü© !!
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is awesome! We have teleported a vast amount information just moving two
bits. It is like seeing a sportsman pulling a truck with his beard!&lt;/p&gt;
&lt;h2 id=&#34;teleportation-technology&#34;&gt;Teleportation technology&lt;/h2&gt;
&lt;p&gt;While this may seem just a theoretical result, recent experiments suggest that
an internet based on quantum technology could be feasible.  A collaborative team of researchers
teleported qubits (as photon states) over a 44 km fiber optic with a fidelity
above 90%. The results have been published in &lt;a href=&#34;https://journals.aps.org/prxquantum/abstract/10.1103/PRXQuantum.1.020317&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;PRX Quantum&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Energetic bonding analysis with ChemInt</title>
      <link>https://zyth0s.github.io/slides/example/</link>
      <pubDate>Fri, 03 Jan 2020 00:00:00 +0000</pubDate>
      <guid>https://zyth0s.github.io/slides/example/</guid>
      <description>&lt;h2 id=&#34;energetic-bonding-analysis-with-chemint&#34;&gt;Energetic bonding analysis with ChemInt&lt;/h2&gt;
&lt;p&gt;Daniel Men√©ndez Crespo&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://cpfs.mpg.de&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;MPI CPFS&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;mpg_logo.svg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;outline&#34;&gt;Outline&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Features&lt;/li&gt;
&lt;li&gt;Basic usage&lt;/li&gt;
&lt;li&gt;Import DGrid surfaces&lt;/li&gt;
&lt;li&gt;Testing &amp;amp; Documentation&lt;/li&gt;
&lt;li&gt;Prototype embedding in DGrid&lt;/li&gt;
&lt;li&gt;Issues&lt;/li&gt;
&lt;li&gt;Draft paper.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;features&#34;&gt;Features&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;For molecular and periodic systems.&lt;/li&gt;
&lt;li&gt;Works with DGrid, Gamess, and PySCF wavefunction formats&lt;/li&gt;
&lt;li&gt;HF and DFT wavefunctions&lt;/li&gt;
&lt;li&gt;Parallel execution&lt;/li&gt;
&lt;li&gt;Exhaustive documentation&lt;/li&gt;
&lt;li&gt;Validity: ca. 39000 tests; 80% coverage&lt;/li&gt;
&lt;li&gt;Interactive&lt;/li&gt;
&lt;li&gt;Julia and C++ versions (both interface DGrid)&lt;/li&gt;
&lt;li&gt;&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;load-a-wavefunction&#34;&gt;Load a wavefunction&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;julia&amp;gt; using ChemInt
julia&amp;gt; wfn = parse_wavefunction(&amp;quot;examples/Al_fcc.fhi&amp;quot;)
[ Info: üìçSystem:
[ Info:   Number of atoms 1
[ Info:   Total charge 13.0
[ Info:   Atom Coordinates (Bohr)
[ Info:   Nuclei 1 with Z = 13.0, position : [0.0, 0.0, 0.0]
[ Info: üìçWavefunction:
[ Info:   Type: ChemInt.DGRIDWFN_Sol_Real
[ Info:   Input file examples/Al_fcc_1x1x1/Al_fcc.fhi
[ Info:   Checksum: 2dac66869215084036016f586bc8f45c389c39d54b71a0b1e5f094d76ade959d
[ Info:   DGrid v5.1.0 JLL wrapper compiled with AppleClang 11.0.3.11030032 (Darwin)
[ Info:   Number of molecular orbitals 9
[ Info:   Number of occupied molecular orbitals 9
[ Info:   Number of molecular primitives 18

&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h3 id=&#34;default-configuration&#34;&gt;Default configuration&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;julia&amp;gt; surfopts = parse_config(wfn)[1]
[ Info: Reproduce the input file used for the calculation:
[ Info: --------------------------------------------------
...
[ Info: --------------------------------------------------
[ Info: üìçSurface options:
[ Info:   Surfaces to be determined: [1]
[ Info:   ODE solver is BS3()
[ Info:   ODE reltol is 0.01
[ Info:   ODE abstol is 0.0001
[ Info:   Limits of search: [10.0]
[ Info:   ‚Ññ of rays is [5810]

&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h3 id=&#34;string-configuration&#34;&gt;String configuration&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;iqaconfig = &amp;quot;&amp;quot;&amp;quot;
[surface]

[angular_quadrature]
  quality = &amp;quot;fine&amp;quot; # coarse | medium | fine | finest

[radial_quadrature]
  quality = &amp;quot;coarse&amp;quot; # coarse | medium | fine | finest

[beta_sphere]
  betasphere   = true
  betafac_atom = [[1,2],[0.5,0.5]]
...
&amp;quot;&amp;quot;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h3 id=&#34;prepare-iqa-calculation&#34;&gt;Prepare IQA calculation&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;name = joinpath(@__DIR__, &amp;quot;lih.wfn&amp;quot;)

surfile = name * &amp;quot;.surf.h5&amp;quot;

wfn = parse_wavefunction(name)
display(wfn)

surfopts, quadopts, xpolaropts, iqaopts,
          dftopts, locopts = parse_config(wfn, iqaconfig)

ChemInt.adjust_beta_sphere!(quadopts, surfile, wfn)
display(quadopts)
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h3 id=&#34;quadrature-options&#34;&gt;Quadrature options&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;julia&amp;gt; quadopts
[ Info: üìçQuadrature options:
[ Info:   Number of angular points  inside [434, 434]
[ Info:   Number of  radial points outside [200, 200]
[ Info:   Number of  radial points  inside [200, 200]
[ Info:   Radial outside quadrature Gauss-Legendre
[ Info:   Radial  inside quadrature Gauss-Legendre
[ Info:   Radial outside mapping 2
[ Info:   Radial  inside mapping 3
[ Info:   Slater-Bragg radii [0.0, 0.0]
[ Info:   Œ≤-sphere factor [0.6, 0.6]
[ Info:   Œ≤-sphere radii [0.0, 0.0]
[ Info:   Rmin of surfaces [0.0, 0.0]
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h3 id=&#34;multi-bi-polar-options&#34;&gt;Multi-/bi-polar options&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;julia&amp;gt; xpolaropts
[ Info: üìçBi-/multi-polar expansion options:
[ Info:   Maximum l orders outside Œ≤-sphere: [6, 6]
[ Info:   Maximum l orders  inside Œ≤-sphere: [4, 4]
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h3 id=&#34;iqa-integration-options&#34;&gt;IQA integration options&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;julia&amp;gt; iqaopts
[ Info: üìçIQA integration options:
[ Info:   ‚Ññ basins to ingegrate: 2
[ Info:   ‚Ññ pairs  to ingegrate: 1
[ Info:   Basins to ingegrate: [1, 2]
[ Info:   Pairs  to ingegrate: [[1, 2]]
[ Info:   Convergence threshold for bipolar = 1.0e-8
[ Info:   Romberg extrapolation? false
[ Info:   Monadic diagonalization? false
[ Info:   Integrate exchange &amp;amp; correlation? true
[ Info:   Orbitals in energy window [-Inf, Inf]
[ Info:   Recovery? false
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h3 id=&#34;dft-options&#34;&gt;DFT options&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;julia&amp;gt; dftopts
[ Info: üìçDFT options:
[ Info:   Activated? true
[ Info:   Kinetic functional:
[ Info:   Exchange or exchange-correlation functional: gga_x_pbe
[ Info:   Correlation functional: gga_c_pbe
[ Info:   Fraction of HF exchange is = 0.0
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h3 id=&#34;find-basin-boundaries&#34;&gt;Find basin boundaries&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;julia&amp;gt; find_surfaces(surfopts, wfn)

[ Info: Surfaces to be determined: [1]
[ Info: Basin    1: 
[ Info:    Trust sphere radius       = 2.2000000000000006
[ Info:    Suggested Œ≤-sphere radius = 1.4000000000000001
[ Info: Basin    1: 
Surface of basin    1: 100%[================] Time: 0:01:03
[ Info:    Closest  surface point min·µ£(||r - Rnuc||) = 2.40
[ Info:    Farthest surface point max·µ£(||r - Rnuc||) = 10.0
...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Writes to &lt;code&gt;*.surf.h5&lt;/code&gt; file.&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;run-iqa&#34;&gt;Run IQA&lt;/h3&gt;
&lt;p&gt;Integrate IQA energy components, LIs, and DIs.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;julia&amp;gt; iqa = iqa_decomposition(surfile, wfn,
                      quadopts, xpolaropts, iqaopts, dftopts)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Writes to &lt;code&gt;*.iqa.#.json&lt;/code&gt; and &lt;code&gt;*.iqa.json&lt;/code&gt; files.&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;iqa-summary-monocentric&#34;&gt;IQA summary: Monocentric&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;julia&amp;gt; iqa.monos[1]
üìçIntra components of basin: 1
  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  kinetic           energy   =      +7.36046127
  self nuc-el       energy   =     -16.39957368
  energy elec(  1)-nuc(  2)  =      -0.69443763
  Coulomb           energy   =      +3.46606343
  xc                energy   =      -1.66088134
  x                 energy   =      -1.66088134
   c                energy   =      +0.00000000
  xc (DFT)          energy   =      +0.00000000
  x  (DFT)          energy   =      +0.00000000
   c (DFT)          energy   =      +0.00000000
  Total ee repusion energy   =      +1.80518210
  Localization index (xc)    =      +1.99249773
  Localization index (x )    =      +1.99249773
  Localization index ( c)    =      +0.00000000
  Self-energy                =      -7.23393032
  Laplacian                  =      +0.00000000
  N¬∫ electrons               =      +2.09697706
  Basin charge               =      +0.90302294
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h3 id=&#34;iqa-summary-interactions&#34;&gt;IQA summary: Interactions&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;julia&amp;gt; iqa.pairs[1]
üìçBicentric analysis of pair 1 2
  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
                                              exact       multipolar             diff
  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  Distance (a‚ÇÄ)                         +3.02173254
  Total interaction                     -0.28058656      +0.64689317      -0.92747973
  NN total repulsion                    +0.99280792
  energy elec(  1)-nuc(  2)             -1.80846292      -0.32421556      -1.48424736
  energy elec(  2)-nuc(  1)             -0.69443763      -0.15707837      -0.53735927
  EE total repulsion                    +1.22950607      +0.13537917      +1.09412690
  EE Coulomb energy                     +1.26367450      +0.13537917      +1.12829533
  EE xc    energy                       -0.03416843      +0.00000000      -0.03416843
  EE x     energy                       -0.03416843      +0.00000000      -0.03416843
  EE  c    energy                       +0.00000000      +0.00000000      +0.00000000
  Clasical interaction (xc out)         -0.24641813      +0.64689317      -0.89331130
  Delocalization index (xc)             +0.20799039
  Delocalization index (x )             +0.20799039
  Delocalization index ( c)             +0.00000000
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h3 id=&#34;iqa-summary-total&#34;&gt;IQA summary: Total&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;julia&amp;gt; iqa
üìçTotal energy components                  ‚ü®Œ®|‚ãÖ|Œ®‚ü©
  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
         TOTAL ENERGY =      -7.97528439  ùìî = ùì£ + ùì•
              KINETIC =      +7.97864654  ùì£
            POTENTIAL =     -15.95393093  ùì• = ùì•nn + ùì•ne + ùì•ee
              NUC-NUC =      +0.99280792  ùì•nn
               NUC-EL =     -20.43317153  ùì•ne
                EL-EL =      +3.48643268  ùì•ee = ùì•H + ùì•xc
        EL-EL Coulomb =      +5.62802512  ùì•H
     EL-EL (Exc+Corr) =      -2.14159244  ùì•xc = ùì•x + ùì•c
           EL-EL Exc  =      -2.14159244  ùì•x
           EL-EL Corr =      +0.00000000  ùì•c
               2ùì£ + ùì• =      +0.00336216
         VIRIAL RATIO =      -1.99957861  ùì•/ùì£
                 ENET =      -7.69469783  ‚àëA   ùìî·¥¨
                 EINT =      -0.28058656  ‚àëA,B ùì•·¥¨·¥Æ
           EINT class =      -0.24641813  ‚àëA,B ùì•nn·¥¨·¥Æ + ùì•ne·¥¨·¥Æ + ùì•ne·¥Æ·¥¨ + ùì•H·¥¨·¥Æ
        EINT exc+corr =      -0.03416843  ‚àëA,B ùì•xc·¥¨·¥Æ
         TOTAL CHARGE =      +0.00865004  Q·¥¨ = ‚àëA (Z·¥¨ - N·¥¨)
  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h3 id=&#34;load-stored-results&#34;&gt;Load stored results&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;julia&amp;gt; iqa = ChemInt.load_iqajson(&amp;quot;examples/lih/lih.gwf.json&amp;quot;)
üìçIntra components of basin: 1
...
üìçBicentric analysis of pair 1 2
...
üìçTotal energy components                  ‚ü®Œ®|‚ãÖ|Œ®‚ü©
...
julia&amp;gt; iqa.CHARGE
0.00041845455180711255

&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h3 id=&#34;analyze-results&#34;&gt;Analyze results&lt;/h3&gt;
&lt;p&gt;For example, check convergence of ùì•H.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;julia&amp;gt; ChemInt.print_convergence(iqa.monos[1], 6)
[ Info: üìç LM Convergence [Total]:
[ Info:     L         COULOMB              XC               X            CORR
[ Info:   --- --------------- --------------- --------------- ---------------
[ Info:     0       +3.465834       -1.659177       -1.659177       +0.000000
[ Info:     1       +3.465981       -1.661697       -1.661697       +0.000000
[ Info:     2       +3.466030       -1.661735       -1.661735       +0.000000
[ Info:     3       +3.466048       -1.661744       -1.661744       +0.000000
[ Info:     4       +3.466053       -1.661747       -1.661747       +0.000000
[ Info:     5       +3.466055       -1.661748       -1.661748       +0.000000
[ Info:     6       +3.466055       -1.661748       -1.661748       +0.000000
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h3 id=&#34;import-dgrid-surfaces&#34;&gt;Import DGrid surfaces&lt;/h3&gt;
&lt;p&gt;Example in &lt;code&gt;examples/LiMgN/convert_basins.jl&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;# 1. Import basins to ChemInt format
import_dgrid_surface(bsn_name, npang, wfn)
...
# 2. Reorder basins if necessary
reorder_surfaces(surfile, mapping)
# 3. Generate point cloud
wfn = parse_wavefunction(wfnfile)
for ibasin in 1:wfn.natm
   raycuts2pointcloud(wfn.coords, surfile; ibasin, format= :csv)
end
# Visualize with Avizo
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h3 id=&#34;heading&#34;&gt;&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;vis_avizo.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;validation&#34;&gt;Validation&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;julia&amp;gt; ]
(ChemInt) pkg&amp;gt; test
    Testing ChemInt
...
Test Summary:                |  Pass  Broken  Total
ChemInt.jl: unit tests       | 38928       5  38933
ChemInt.jl: integrated tests | 1158           1158
ChemInt.jl: full examples    |  120           120
    Testing ChemInt tests passed

&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h3 id=&#34;unit-tests&#34;&gt;Unit tests&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;ChemInt.jl: unit tests                         | 38992     1       5  38998
  Parsing of AIM WFN format                    |    22                   22
  Parsing of DGrid Gamess AIM format: LiH      |    16                   16
  Parsing of DGrid FHI-aims format: Al Œì-point |    15                   15
  WFN traits                                   |    31             5     36
  ‚àáœÅ(ùê´): Fortran ‚â° Promolden                   |     5                    5
  ‚àáœÅ(ùê´): Julia   ‚â° Promolden                   |     5                    5
  ‚àáœÅ(ùê´): Julia   ‚â° Fortran                     |   101                  101
  ‚àáœÅ(ùê´): DGrid routines ‚â° bpy                  |     4                    4
  ‚àáœÅ(ùê´): Wrapper  ‚â° DGrid                      |     6                    6
  œÅ(ùê´): ChemInt ‚â° Promolden                    |     7                    7
  œÅ(ùê´): DGridJLL ‚â° Promolden                   |     7                    7
  œÅ(ùíì): DGridJLL ‚â° DGrid                       |     2                    2
  œÅ(ùê´): Equivalence of routines                |   402                  402
  œÑ(ùê´): ChemInt ‚â° Promolden                    |     7                    7
  œÑ(ùê´): DGridJLL ‚â° Promolden                   |     7                    7
  œÑ(ùê´): Equivalence of routines                |   402                  402
  œÉ(ùê´): ChemInt ‚â° Promolden                    |     5                    5
  œÉ(ùê´): DGridJLL ‚â° Promolden                   |     5                    5
  œÉ(ùê´): Equivalence of routines                |   202                  202
  ŒîœÅ(ùê´): ChemInt ‚â° Promolden                   |     3                    3
  ŒîœÅ(ùê´): DGridJLL ‚â° Promolden                  |     3                    3
  ùóõœÅ(ùê´): vs Promolden                          |     3                    3
  œÅ·µ¢‚±º(ùê´): ChemInt ‚â° Promolden                  |                      No tests
  œÅ·µ¢‚±º(ùê´): Equivalence of routines              |   201                  201
  Defaults: surface                            |    26                   26
  Defaults: quadrature                         |    60                   60
  Defaults: x-polar                            |    23                   23
  Defaults: IQA integration                    |    37                   37
  Defaults: DFT                                |    13                   13
  Defaults: Localization                       |     5                    5
  TOML parsing: surface                        |     4                    4
  TOML parsing: quadrature                     |     3                    3
  TOML parsing: x-polar                        |     1                    1
  TOML parsing: IQA integration                |     4                    4
  TOML parsing: DFT                            |                      No tests
  TOML parsing: Localization                   |                      No tests
  Sphere quadrature: Lebedev-Laikov            |    96                   96
  Radial quadrature: Euler-McLaurin            |     9                    9
  Radial quadrature: Gauss-Legendre            |    48                   48
  Radial quadrature: Clenshaw-Curtis           |   700                  700
  Radial quadrature: Gauss-Chebyshev 1st order |    19                   19
  Radial quadrature: Gauss-Chebyshev 2nd order |     9                    9
  Radial quadrature: Trapezoidal               |     9                    9
  n!                                           |    16                   16
  n!!                                          |   171                  171
  Real Spherical Harmonics                     |     6                    6
  c·µè                                           |    49                   49
  d·µè                                           | 33938                33938
  ùëª                                            |     2                    2
  IQA_Mono_OutŒ≤ data                           |    35                   35
  IQA_Mono_InŒ≤ data                            |    33                   33
  IQA_Mono data                                |    36                   36
  Mono += Region                               |     6                    6
  IQA_Pair data                                |    40                   40
  IQA data                                     |    25                   25
  Œîm                                           |     1                    1
  ùì•·µÉ                                           |                      No tests
  ùì•mat                                         |  2088                 2088
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h3 id=&#34;heading-1&#34;&gt;&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;coverage.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;file-organization&#34;&gt;File organization&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ChemInt&lt;/code&gt;: main file.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;data_wfn&lt;/code&gt;: hold WFN parameters.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;data_iqa&lt;/code&gt;: hold IQA energies.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;opts_*&lt;/code&gt;: hold calculation options.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;iqa_decomposition&lt;/code&gt;: IQA integration driver&lt;/li&gt;
&lt;li&gt;&lt;code&gt;find_surfaces&lt;/code&gt;: surface search driver&lt;/li&gt;
&lt;li&gt;&lt;code&gt;eval_*&lt;/code&gt;: evaluation of point properties&lt;/li&gt;
&lt;li&gt;&lt;code&gt;monocentric_*&lt;/code&gt;: monocentric integrals&lt;/li&gt;
&lt;li&gt;&lt;code&gt;bicentric_*&lt;/code&gt;: bicentric integrals&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;further-details&#34;&gt;Further details&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;See the documentation at &lt;code&gt;docs/build/html/index.html&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Build with &lt;code&gt;makedocs.sh&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;docs_header.png&#34; alt=&#34;Documentation&#34;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;embedding&#34;&gt;Embedding&lt;/h3&gt;
&lt;p&gt;Example calling ChemInt from C in &lt;code&gt;embedded&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Pass the configuration string and a logging filename to ChemInt, which
logs the progress and generates the &lt;code&gt;*.json&lt;/code&gt; files with the outputs.
Those files can be read with &lt;code&gt;load_iqajson()&lt;/code&gt;.&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;issues&#34;&gt;Issues&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Integration accuracy. Example: Charge error in LiMgN conventional cell is 0.15 e.
&lt;ul&gt;
&lt;li&gt;Changing integration parameters does not reduce error.&lt;/li&gt;
&lt;li&gt;Surface perturbation alters the error. Even if surface is imported from DGrid.&lt;/li&gt;
&lt;li&gt;Integration routines were carefully tested.&lt;/li&gt;
&lt;li&gt;Refined surface but it was worse.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Basin integration: Close to DGrid.&lt;/p&gt;
&lt;p&gt;Cell integration: Errors add up. Is it tolerable?&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;draft&#34;&gt;Draft&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;paper_abstract.png&#34; alt=&#34;draft&#34;&gt;&lt;/p&gt;
&lt;p&gt;Comments, suggestions?&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Integration accuracy with ChemInt</title>
      <link>https://zyth0s.github.io/slides/integ_accuracy/</link>
      <pubDate>Fri, 03 Jan 2020 00:00:00 +0000</pubDate>
      <guid>https://zyth0s.github.io/slides/integ_accuracy/</guid>
      <description>&lt;h3 id=&#34;outline&#34;&gt;Outline&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;LiMgN
&lt;ul&gt;
&lt;li&gt;Calculated surface
&lt;ul&gt;
&lt;li&gt;Volume; Charge&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Imported surface
&lt;ul&gt;
&lt;li&gt;Volume; Laplacian; Charge&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;BeAlB
&lt;ul&gt;
&lt;li&gt;Calculated surface
&lt;ul&gt;
&lt;li&gt;Volume; Charge&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;LiAlSi
&lt;ul&gt;
&lt;li&gt;Calculated surface
&lt;ul&gt;
&lt;li&gt;Volume; Charge&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;1-limgn-calculated-surface&#34;&gt;1. &lt;code&gt;LiMgN&lt;/code&gt;: Calculated surface&lt;/h2&gt;
&lt;p&gt;That is, surface computed with an internal algorithm.&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;limgn-volume-bohr3&#34;&gt;&lt;code&gt;LiMgN Volume (bohr^3)&lt;/code&gt;&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;Li&lt;/th&gt;
&lt;th&gt;Mg&lt;/th&gt;
&lt;th&gt;N&lt;/th&gt;
&lt;th&gt;Cell&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;ChemInt CalcSurf&lt;/td&gt;
&lt;td&gt;20.95&lt;/td&gt;
&lt;td&gt;42.86&lt;/td&gt;
&lt;td&gt;151.42&lt;/td&gt;
&lt;td&gt;861.32&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;DGrid&lt;/td&gt;
&lt;td&gt;20.74&lt;/td&gt;
&lt;td&gt;38.57&lt;/td&gt;
&lt;td&gt;151.96&lt;/td&gt;
&lt;td&gt;845.08&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$\Delta V$&lt;/td&gt;
&lt;td&gt;0.21&lt;/td&gt;
&lt;td&gt;4.29&lt;/td&gt;
&lt;td&gt;0.54&lt;/td&gt;
&lt;td&gt;16.24&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Li has spikes and Mg has a crest.&lt;/p&gt;
&lt;p&gt;Error concentrated in Mg basins.&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;li-basin&#34;&gt;&lt;code&gt;Li basin&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;LiMgN_basin_Li.jpg&#34; alt=&#34;Li basin&#34;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;mg-basin&#34;&gt;&lt;code&gt;Mg basin&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;LiMgN_basin_Mg.jpg&#34; alt=&#34;Mg basin&#34;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;limgn-charge-e&#34;&gt;&lt;code&gt;LiMgN Charge (e)&lt;/code&gt;&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;Li&lt;/th&gt;
&lt;th&gt;Mg&lt;/th&gt;
&lt;th&gt;N&lt;/th&gt;
&lt;th&gt;Cell&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;ChemInt CalcSurf&lt;/td&gt;
&lt;td&gt;0.82&lt;/td&gt;
&lt;td&gt;1.56&lt;/td&gt;
&lt;td&gt;-2.42&lt;/td&gt;
&lt;td&gt;-0.15&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;DGrid&lt;/td&gt;
&lt;td&gt;0.83&lt;/td&gt;
&lt;td&gt;1.60&lt;/td&gt;
&lt;td&gt;-2.43&lt;/td&gt;
&lt;td&gt;+0.00&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$\Delta V$&lt;/td&gt;
&lt;td&gt;0.01&lt;/td&gt;
&lt;td&gt;0.04&lt;/td&gt;
&lt;td&gt;+0.01&lt;/td&gt;
&lt;td&gt;-0.15&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Error concentrated in Mg basins.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;2-limgn-imported-dgrid-surface&#34;&gt;2. &lt;code&gt;LiMgN&lt;/code&gt;: Imported DGrid surface&lt;/h2&gt;
&lt;hr&gt;
&lt;h3 id=&#34;limgn-volume-bohr3-1&#34;&gt;&lt;code&gt;LiMgN Volume (bohr^3)&lt;/code&gt;&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;Li&lt;/th&gt;
&lt;th&gt;Mg&lt;/th&gt;
&lt;th&gt;N&lt;/th&gt;
&lt;th&gt;Cell&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;ChemInt ImportSurf&lt;/td&gt;
&lt;td&gt;21.19&lt;/td&gt;
&lt;td&gt;40.01&lt;/td&gt;
&lt;td&gt;153.32&lt;/td&gt;
&lt;td&gt;857.96&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;DGrid&lt;/td&gt;
&lt;td&gt;20.74&lt;/td&gt;
&lt;td&gt;38.57&lt;/td&gt;
&lt;td&gt;151.96&lt;/td&gt;
&lt;td&gt;845.08&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$\Delta V$&lt;/td&gt;
&lt;td&gt;0.45&lt;/td&gt;
&lt;td&gt;1.44&lt;/td&gt;
&lt;td&gt;2.50&lt;/td&gt;
&lt;td&gt;12.88&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;$\sigma(V^{Li}) = 0.5$;
$\sigma(V^{Mg}) = 0.6$;
$\sigma(V^{N})  = 0.3$.&lt;/p&gt;
&lt;p&gt;No spikes or crests.&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;li-basin-imported&#34;&gt;&lt;code&gt;Li basin imported&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;LiMgN_basin_Li_import.jpg&#34; alt=&#34;Li basin imported&#34;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;mg-basin-imported&#34;&gt;&lt;code&gt;Mg basin imported&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;LiMgN_basin_Mg_import.jpg&#34; alt=&#34;Mg basin imported&#34;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;n-basin-imported&#34;&gt;&lt;code&gt;N basin imported&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;LiMgN_basin_N_import.jpg&#34; alt=&#34;N basin imported&#34;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;limgn-laplacian-au&#34;&gt;&lt;code&gt;LiMgN Laplacian (a.u.)&lt;/code&gt;&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;Li&lt;/th&gt;
&lt;th&gt;Mg&lt;/th&gt;
&lt;th&gt;N&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;ChemInt ImportSurf&lt;/td&gt;
&lt;td&gt;0.034&lt;/td&gt;
&lt;td&gt;0.015&lt;/td&gt;
&lt;td&gt;0.015&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;$\sigma(\Delta\rho^{Li}) = 0.024$;
$\sigma(\Delta\rho^{Mg}) = 0.042$;
$\sigma(\Delta\rho^{N})  = 0.003$.&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;limgn-charge-e-1&#34;&gt;&lt;code&gt;LiMgN Charge (e)&lt;/code&gt;&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;Li&lt;/th&gt;
&lt;th&gt;Mg&lt;/th&gt;
&lt;th&gt;N&lt;/th&gt;
&lt;th&gt;Cell&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;ChemInt ImportSurf&lt;/td&gt;
&lt;td&gt;0.81&lt;/td&gt;
&lt;td&gt;1.57&lt;/td&gt;
&lt;td&gt;-2.43&lt;/td&gt;
&lt;td&gt;-0.17&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;DGrid&lt;/td&gt;
&lt;td&gt;0.83&lt;/td&gt;
&lt;td&gt;1.60&lt;/td&gt;
&lt;td&gt;-2.43&lt;/td&gt;
&lt;td&gt;+0.00&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$\Delta V$&lt;/td&gt;
&lt;td&gt;0.02&lt;/td&gt;
&lt;td&gt;0.03&lt;/td&gt;
&lt;td&gt;+0.00&lt;/td&gt;
&lt;td&gt;-0.17&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;$\sigma(Q^{Li}) = 0.00$;
$\sigma(Q^{Mg}) = 0.01$;
$\sigma(Q^{N})  = 0.00$.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;1-bealb-calculated-surface&#34;&gt;1. &lt;code&gt;BeAlB&lt;/code&gt;: Calculated surface&lt;/h2&gt;
&lt;p&gt;With an internal algorithm.&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;bealb-volume-bohr3&#34;&gt;&lt;code&gt;BeAlB Volume (bohr^3)&lt;/code&gt;&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;Be&lt;/th&gt;
&lt;th&gt;Al&lt;/th&gt;
&lt;th&gt;B&lt;/th&gt;
&lt;th&gt;Cell&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;ChemInt ImportSurf&lt;/td&gt;
&lt;td&gt;18.31&lt;/td&gt;
&lt;td&gt;35.02&lt;/td&gt;
&lt;td&gt;155.45&lt;/td&gt;
&lt;td&gt;835.11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;DGrid&lt;/td&gt;
&lt;td&gt;17.16&lt;/td&gt;
&lt;td&gt;33.28&lt;/td&gt;
&lt;td&gt;155.68&lt;/td&gt;
&lt;td&gt;824.48&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$\Delta V$&lt;/td&gt;
&lt;td&gt;1.25&lt;/td&gt;
&lt;td&gt;1.74&lt;/td&gt;
&lt;td&gt;0.23&lt;/td&gt;
&lt;td&gt;11.37&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;h3 id=&#34;be-basin&#34;&gt;&lt;code&gt;Be basin&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;BeAlB_basin_Be.jpg&#34; alt=&#34;Be basin&#34;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;al-basin&#34;&gt;&lt;code&gt;Al basin&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;BeAlB_basin_Al.jpg&#34; alt=&#34;Al basin&#34;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;b-basin&#34;&gt;&lt;code&gt;B basin&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;BeAlB_basin_B.jpg&#34; alt=&#34;B basin&#34;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;bealb-charge-e&#34;&gt;&lt;code&gt;BeAlB Charge (e)&lt;/code&gt;&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;Be&lt;/th&gt;
&lt;th&gt;Al&lt;/th&gt;
&lt;th&gt;B&lt;/th&gt;
&lt;th&gt;Cell&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;ChemInt ImportSurf&lt;/td&gt;
&lt;td&gt;1.47&lt;/td&gt;
&lt;td&gt;2.14&lt;/td&gt;
&lt;td&gt;-3.66&lt;/td&gt;
&lt;td&gt;-0.20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;DGrid&lt;/td&gt;
&lt;td&gt;1.50&lt;/td&gt;
&lt;td&gt;2.17&lt;/td&gt;
&lt;td&gt;-3.67&lt;/td&gt;
&lt;td&gt;+0.00&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$\Delta V$&lt;/td&gt;
&lt;td&gt;0.03&lt;/td&gt;
&lt;td&gt;0.03&lt;/td&gt;
&lt;td&gt;-0.01&lt;/td&gt;
&lt;td&gt;-0.20&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;h2 id=&#34;1-lialsi-calculated-surface&#34;&gt;1. &lt;code&gt;LiAlSi&lt;/code&gt;: Calculated surface&lt;/h2&gt;
&lt;p&gt;With an internal algorithm.&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;lialsi-volume-bohr3&#34;&gt;&lt;code&gt;LiAlSi Volume (bohr^3)&lt;/code&gt;&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;Li&lt;/th&gt;
&lt;th&gt;Al&lt;/th&gt;
&lt;th&gt;Si&lt;/th&gt;
&lt;th&gt;Cell&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;ChemInt ImportSurf&lt;/td&gt;
&lt;td&gt;24.95&lt;/td&gt;
&lt;td&gt;76.83&lt;/td&gt;
&lt;td&gt;253.10&lt;/td&gt;
&lt;td&gt;1423.49&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;DGrid&lt;/td&gt;
&lt;td&gt;24.50&lt;/td&gt;
&lt;td&gt;74.23&lt;/td&gt;
&lt;td&gt;254.31&lt;/td&gt;
&lt;td&gt;1412.16&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$\Delta V$&lt;/td&gt;
&lt;td&gt;0.45&lt;/td&gt;
&lt;td&gt;2.60&lt;/td&gt;
&lt;td&gt;1.21&lt;/td&gt;
&lt;td&gt;11.33&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;h3 id=&#34;lialsi-charge-e&#34;&gt;&lt;code&gt;LiAlSi Charge (e)&lt;/code&gt;&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;Li&lt;/th&gt;
&lt;th&gt;Al&lt;/th&gt;
&lt;th&gt;Si&lt;/th&gt;
&lt;th&gt;Cell&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;ChemInt ImportSurf&lt;/td&gt;
&lt;td&gt;0.83&lt;/td&gt;
&lt;td&gt;1.56&lt;/td&gt;
&lt;td&gt;-2.41&lt;/td&gt;
&lt;td&gt;-0.08&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;DGrid&lt;/td&gt;
&lt;td&gt;0.83&lt;/td&gt;
&lt;td&gt;1.58&lt;/td&gt;
&lt;td&gt;-2.41&lt;/td&gt;
&lt;td&gt;+0.00&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$\Delta V$&lt;/td&gt;
&lt;td&gt;0.00&lt;/td&gt;
&lt;td&gt;0.02&lt;/td&gt;
&lt;td&gt;+0.00&lt;/td&gt;
&lt;td&gt;-0.08&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
</description>
    </item>
    
    <item>
      <title>Real‚ÄêSpace In Situ Bond Energies: Toward A Consistent Energetic Definition of Bond Strength</title>
      <link>https://zyth0s.github.io/publication/realspace-in-situ-bond-energies-toward-a-consistent-energetic-definition-of-bond-strength/</link>
      <pubDate>Sat, 14 Apr 2018 17:55:43 +0000</pubDate>
      <guid>https://zyth0s.github.io/publication/realspace-in-situ-bond-energies-toward-a-consistent-energetic-definition-of-bond-strength/</guid>
      <description></description>
    </item>
    
    <item>
      <title>A multipolar approach to the interatomic covalent interaction energy</title>
      <link>https://zyth0s.github.io/publication/a-multipolar-approach-to-the-interatomic-covalent-interaction-energy/</link>
      <pubDate>Thu, 16 Feb 2017 19:33:15 +0000</pubDate>
      <guid>https://zyth0s.github.io/publication/a-multipolar-approach-to-the-interatomic-covalent-interaction-energy/</guid>
      <description></description>
    </item>
    
    <item>
      <title>An unexpected bridge between chemical bonding indicators and electrical conductivity through the localization tensor</title>
      <link>https://zyth0s.github.io/publication/an-unexpected-bridge-between-chemical-bonding-indicators-and-electrical-conductivity-through-the-localization-tensor/</link>
      <pubDate>Mon, 12 Dec 2016 19:40:06 +0000</pubDate>
      <guid>https://zyth0s.github.io/publication/an-unexpected-bridge-between-chemical-bonding-indicators-and-electrical-conductivity-through-the-localization-tensor/</guid>
      <description></description>
    </item>
    
  </channel>
</rss>
